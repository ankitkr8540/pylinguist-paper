English_code,Partial_translated_code,google_translated_code
"for i in range(10):  # First digit
    for j in range(10):  # Second digit
        for k in range(10):  # Third digit
            # Checking for the conditions
            if i != 5 and j != 5 and k != 5 and i != j and i != k and j != k:
                print(i, j, k)","بۆ i لەناو ڕێژە(10): #First digit
    بۆ j لەناو ڕێژە(10): #Second digit
        بۆ k لەناو ڕێژە(10): #Third digit
             #Checking for the conditions
            ئەگەر i != 5 و j != 5 و k != 5 و i != j و i != k و j != k:
                چاپکردن(i, j, k)","بۆ ez لەناو ڕێژە(10): # Hejmarek yekem
    بۆ J لەناو ڕێژە(10): # Hejmar duyemîn
        بۆ k لەناو ڕێژە(10): # Hejmar sêyemîn
              # Kontrolkirina şertan
            ئەگەر ez != 5 و J != 5 و k != 5 و ez != J و ez != k و J != k:
                چاپکردن(ez, J, k)"
"def count_distinct_states(matrix):
    count = 0
    states = set()
    for row in matrix:
        for col in row:
            state = ''.join(col)
            if state not in states:
                count += 1
            states.add(state)
    return count

matrix = [['A', 'B', 'C'],
          ['A', 'B', 'D'],
          ['A', 'B', 'C']]
print(count_distinct_states(matrix))
# Output: 4","پێناسەکردن count_distinct_states(matrix):
    گێرانەوە = 0
    states = دانان()
    بۆ row لەناو matrix:
        بۆ col لەناو row:
            state = ''.پەیوەندیکردن(col)
            ئەگەر state نەخێر لەناو states:
                گێرانەوە += 1
            states.زیادکردن(state)
    گەڕانەوە گێرانەوە

matrix = [['A', 'B', 'C'],
          ['A', 'B', 'D'],
          ['A', 'B', 'C']]
چاپکردن(count_distinct_states(matrix))
 #Output: 4","پێناسەکردن Dewletên_cihêreng_hejmartin(matrix):
    گێرانەوە = 0
    dewlete = دانان()
    بۆ bêrkirin لەناو matrix:
        بۆ col لەناو bêrkirin:
            rewş = ''.پەیوەندیکردن(col)
            ئەگەر rewş نەخێر لەناو dewlete:
                گێرانەوە += 1
            dewlete.زیادکردن(rewş)
    گەڕانەوە گێرانەوە

matrix = [['A', 'B', 'C'],
          ['A', 'B', 'D'],
          ['A', 'B', 'C']]
چاپکردن(Dewletên_cihêreng_hejmartin(matrix))
  # Derket: 4"
"def remove_spaces_and_punctuation(s):
    result = """"
    for char in s:
        if char.isalnum():
            result += char
    return result","پێناسەکردن remove_spaces_and_punctuation(s):
    result = """"
    بۆ char لەناو s:
        ئەگەر char.ئەلفوبێی_ژمارەییە():
            result += char
    گەڕانەوە result","پێناسەکردن dever_û_xalên_rakirin(S):
    netîce = """"
    بۆ ekar لەناو S:
        ئەگەر ekar.ئەلفوبێی_ژمارەییە():
            netîce += ekar
    گەڕانەوە netîce"
"import math

def is_prime(n):
    # Check if the number is less than 2 or not an integer
    if n < 2 or not isinstance(n, int):
        return ""Not Prime""

    # Check if the number is divisible by any integer from 2 to the square root of n
    for i in range(2, math.isqrt(n) + 1):
        if n % i == 0:
            return ""Not Prime""

    return ""Prime""","هاوردەکردن math

پێناسەکردن is_prime(n):
     #Check if the number is less than 2 or not an integer
    ئەگەر n < 2 یان نەخێر نموونەیە(n, ژمارەیەکی_تەواو):
        گەڕانەوە ""Not Prime""

     #Check if the number is divisible by any integer from 2 to the square root of n
    بۆ i لەناو ڕێژە(2, math.isqrt(n) + 1):
        ئەگەر n % i == 0:
            گەڕانەوە ""Not Prime""

    گەڕانەوە ""Prime""","هاوردەکردن Zimanê_kanîn

پێناسەکردن Serokwezîr_e(N):
      # Kontrol bikin ku hejmar ji 2 kêmtir e an ne yek in
    ئەگەر N < 2 یان نەخێر نموونەیە(N, ژمارەیەکی_تەواو):
        گەڕانەوە ""Not Prime""

      # Kontrol bikin ka hejmar ji hêla her hejmarek ji 2_ê heya rootê meydana n
    بۆ ez لەناو ڕێژە(2, Zimanê_kanîn.Isqrt(N) + 1):
        ئەگەر N % ez == 0:
            گەڕانەوە ""Not Prime""

    گەڕانەوە ""Prime"""
"class String:
    def __init__(self, string):
        self.string = string

    def replace_odd_occurrences(self, substring, replace_with):
        count = self.string.count(substring)
        if count % 2 == 0 or count == 0:
            return self.string

        result = """"
        stack = []

        for i in range(len(self.string)):
            if self.string[i:i+len(substring)] == substring:
                if len(stack) > 0 and (stack[-1] == '(' or stack[-1] == '['):
                    stack.append(substring)
                    result += substring
                elif len(stack) > 0 and (stack[-1] == ')' or stack[-1] == ']'):
                    stack.pop()
                    result += substring
                else:
                    stack.append(substring)
                    result += replace_with
            else:
                result += self.string[i]

            if len(stack) > 0 and stack[-1] == substring:
                stack.pop()

        return result","پۆل String:
    پێناسەکردن __init__(self, string):
        self.string = string

    پێناسەکردن replace_odd_occurrences(self, substring, replace_with):
        گێرانەوە = self.string.گێرانەوە(substring)
        ئەگەر گێرانەوە % 2 == 0 یان گێرانەوە == 0:
            گەڕانەوە self.string

        result = """"
        stack = []

        بۆ i لەناو ڕێژە(درێژی(self.string)):
            ئەگەر self.string[i:i+درێژی(substring)] == substring:
                ئەگەر درێژی(stack) > 0 و (stack[-1] == '(' یان stack[-1] == '['):
                    stack.زیاد_بکە(substring)
                    result += substring
                ئەگەرنا_ئەگەر... درێژی(stack) > 0 و (stack[-1] == ')' یان stack[-1] == ']'):
                    stack.پۆپ()
                    result += substring
                ئی_تر:
                    stack.زیاد_بکە(substring)
                    result += replace_with
            ئی_تر:
                result += self.string[i]

            ئەگەر درێژی(stack) > 0 و stack[-1] == substring:
                stack.پۆپ()

        گەڕانەوە result","پۆل Ben:
    پێناسەکردن __init__(self, ben):
        self.ben = ben

    پێناسەکردن bûyerên_ecêb_biguhezînin(self, Substring, bi):
        گێرانەوە = self.ben.گێرانەوە(Substring)
        ئەگەر گێرانەوە % 2 == 0 یان گێرانەوە == 0:
            گەڕانەوە self.ben

        netîce = """"
        lod = []

        بۆ ez لەناو ڕێژە(درێژی(self.ben)):
            ئەگەر self.ben[ez:ez+درێژی(Substring)] == Substring:
                ئەگەر درێژی(lod) > 0 و (lod[-1] == '(' یان lod[-1] == '['):
                    lod.زیاد_بکە(Substring)
                    netîce += Substring
                ئەگەرنا_ئەگەر... درێژی(lod) > 0 و (lod[-1] == ')' یان lod[-1] == ']'):
                    lod.پۆپ()
                    netîce += Substring
                ئی_تر:
                    lod.زیاد_بکە(Substring)
                    netîce += bi
            ئی_تر:
                netîce += self.ben[ez]

            ئەگەر درێژی(lod) > 0 و lod[-1] == Substring:
                lod.پۆپ()

        گەڕانەوە netîce"
"def is_prime(num):
    if num <= 1:
        return False
    for i in range(2, int(num**0.5) + 1):
        if num % i == 0:
            return False
    return True

def has_digit_7(num):
    while num > 0:
        if num % 10 == 7:
            return True
        num //= 10
    return False

def sum_of_primes():
    sum_of_primes = 0
    for num in range(1000000, 2000001):
        if is_prime(num) and not has_digit_7(num):
            sum_of_primes += num
    return sum_of_primes

result = sum_of_primes()
print(""The sum of all prime numbers between 1 million and 2 million, excluding prime numbers that contain the digit 7, is:"", result)","پێناسەکردن is_prime(num):
    ئەگەر num <= 1:
        گەڕانەوە هەڵە
    بۆ i لەناو ڕێژە(2, ژمارەیەکی_تەواو(num**0.5) + 1):
        ئەگەر num % i == 0:
            گەڕانەوە هەڵە
    گەڕانەوە ڕاست

پێناسەکردن has_digit_7(num):
    لەکاتێکدا num > 0:
        ئەگەر num % 10 == 7:
            گەڕانەوە ڕاست
        num //= 10
    گەڕانەوە هەڵە

پێناسەکردن sum_of_primes():
    sum_of_primes = 0
    بۆ num لەناو ڕێژە(1000000, 2000001):
        ئەگەر is_prime(num) و نەخێر has_digit_7(num):
            sum_of_primes += num
    گەڕانەوە sum_of_primes

result = sum_of_primes()
چاپکردن(""The sum of all prime numbers between 1 million and 2 million, excluding prime numbers that contain the digit 7, is:"", result)","پێناسەکردن Serokwezîr_e(n_ê):
    ئەگەر n_ê <= 1:
        گەڕانەوە هەڵە
    بۆ ez لەناو ڕێژە(2, ژمارەیەکی_تەواو(n_ê**0.5) + 1):
        ئەگەر n_ê % ez == 0:
            گەڕانەوە هەڵە
    گەڕانەوە ڕاست

پێناسەکردن hejmar_7_heye(n_ê):
    لەکاتێکدا n_ê > 0:
        ئەگەر n_ê % 10 == 7:
            گەڕانەوە ڕاست
        n_ê //= 10
    گەڕانەوە هەڵە

پێناسەکردن sum_primes():
    sum_primes = 0
    بۆ n_ê لەناو ڕێژە(1000000, 2000001):
        ئەگەر Serokwezîr_e(n_ê) و نەخێر hejmar_7_heye(n_ê):
            sum_primes += n_ê
    گەڕانەوە sum_primes

netîce = sum_primes()
چاپکردن(""The sum of all prime numbers between 1 million and 2 million, excluding prime numbers that contain the digit 7, is:"", netîce)"
"def is_prime(num):
    if num < 2:
        return False
    for i in range(2, int(num ** 0.5) + 1):
        if num % i == 0:
            return False
    return True

def find_prime_sum_array(N, M, X):
    prime_sum_array = []
    current_number = M
    sum_so_far = 0

    while len(prime_sum_array) < N and current_number <= X:
        if is_prime(sum_so_far + current_number):
            prime_sum_array.append(current_number)
            sum_so_far += current_number
        current_number += M

    if not is_prime(sum_so_far):
        return []

    return prime_sum_array

# Example usage
N = 5
M = 3
X = 20

result = find_prime_sum_array(N, M, X)
print(result)","پێناسەکردن is_prime(num):
    ئەگەر num < 2:
        گەڕانەوە هەڵە
    بۆ i لەناو ڕێژە(2, ژمارەیەکی_تەواو(num ** 0.5) + 1):
        ئەگەر num % i == 0:
            گەڕانەوە هەڵە
    گەڕانەوە ڕاست

پێناسەکردن find_prime_sum_array(N, M, X):
    prime_sum_array = []
    current_number = M
    sum_so_far = 0

    لەکاتێکدا درێژی(prime_sum_array) < N و current_number <= X:
        ئەگەر is_prime(sum_so_far + current_number):
            prime_sum_array.زیاد_بکە(current_number)
            sum_so_far += current_number
        current_number += M

    ئەگەر نەخێر is_prime(sum_so_far):
        گەڕانەوە []

    گەڕانەوە prime_sum_array

 #Example usage
N = 5
M = 3
X = 20

result = find_prime_sum_array(N, M, X)
چاپکردن(result)","پێناسەکردن Serokwezîr_e(n_ê):
    ئەگەر n_ê < 2:
        گەڕانەوە هەڵە
    بۆ ez لەناو ڕێژە(2, ژمارەیەکی_تەواو(n_ê ** 0.5) + 1):
        ئەگەر n_ê % ez == 0:
            گەڕانەوە هەڵە
    گەڕانەوە ڕاست

پێناسەکردن array_seroka_pêşîn_bibînin(N, M, X):
    Serokwezîrê_Serokwezîr = []
    Hejmara_heyî = M
    heta_nuha = 0

    لەکاتێکدا درێژی(Serokwezîrê_Serokwezîr) < N و Hejmara_heyî <= X:
        ئەگەر Serokwezîr_e(heta_nuha + Hejmara_heyî):
            Serokwezîrê_Serokwezîr.زیاد_بکە(Hejmara_heyî)
            heta_nuha += Hejmara_heyî
        Hejmara_heyî += M

    ئەگەر نەخێر Serokwezîr_e(heta_nuha):
        گەڕانەوە []

    گەڕانەوە Serokwezîrê_Serokwezîr

  # Bikaranîna mînakî
N = 5
M = 3
X = 20

netîce = array_seroka_pêşîn_bibînin(N, M, X)
چاپکردن(netîce)"
"def is_prime(n):
    if n < 2:
        return False
    for i in range(2, int(n**0.5) + 1):
        if n % i == 0:
            return False
    return True

def max_prime_difference(arr):
    primes = []
    for num in arr:
        if is_prime(abs(num)):
            primes.append(abs(num))
    if len(primes) < 2:
        return 0
    max_diff = 0
    for i in range(len(primes)-1):
        diff = abs(primes[i] - primes[i+1])
        if diff > max_diff:
            max_diff = diff
    return max_diff","پێناسەکردن is_prime(n):
    ئەگەر n < 2:
        گەڕانەوە هەڵە
    بۆ i لەناو ڕێژە(2, ژمارەیەکی_تەواو(n**0.5) + 1):
        ئەگەر n % i == 0:
            گەڕانەوە هەڵە
    گەڕانەوە ڕاست

پێناسەکردن max_prime_difference(arr):
    primes = []
    بۆ num لەناو arr:
        ئەگەر is_prime(بەهای_ڕەها(num)):
            primes.زیاد_بکە(بەهای_ڕەها(num))
    ئەگەر درێژی(primes) < 2:
        گەڕانەوە 0
    max_diff = 0
    بۆ i لەناو ڕێژە(درێژی(primes)-1):
        diff = بەهای_ڕەها(primes[i] - primes[i+1])
        ئەگەر diff > max_diff:
            max_diff = diff
    گەڕانەوە max_diff","پێناسەکردن Serokwezîr_e(N):
    ئەگەر N < 2:
        گەڕانەوە هەڵە
    بۆ ez لەناو ڕێژە(2, ژمارەیەکی_تەواو(N**0.5) + 1):
        ئەگەر N % ez == 0:
            گەڕانەوە هەڵە
    گەڕانەوە ڕاست

پێناسەکردن Cûdahiya_herî_Max(tar):
    Primes = []
    بۆ n_ê لەناو tar:
        ئەگەر Serokwezîr_e(بەهای_ڕەها(n_ê)):
            Primes.زیاد_بکە(بەهای_ڕەها(n_ê))
    ئەگەر درێژی(Primes) < 2:
        گەڕانەوە 0
    Max_diff = 0
    بۆ ez لەناو ڕێژە(درێژی(Primes)-1):
        cihê = بەهای_ڕەها(Primes[ez] - Primes[ez+1])
        ئەگەر cihê > Max_diff:
            Max_diff = cihê
    گەڕانەوە Max_diff"
"import math

def calculate_triangle_height(angle, side_lengths, opposite_side_length, side_ratio):
    # Convert angle from degrees to radians
    angle_rad = math.radians(angle)

    # Calculate the height using the Law of Sines
    height = opposite_side_length * math.sin(angle_rad) / side_ratio

    # Calculate the length of the adjacent side using the Law of Cosines
    adjacent_side_length = math.sqrt(side_lengths**2 + opposite_side_length**2 - 2 * side_lengths * opposite_side_length * math.cos(angle_rad))

    # Calculate the hypotenuse of the triangle
    hypotenuse = side_lengths / math.cos(angle_rad)

    # Calculate the remaining side using Pythagorean theorem
    remaining_side_length = math.sqrt(hypotenuse**2 - adjacent_side_length**2)

    # Calculate the final height of the triangle
    height += remaining_side_length

    return height


def simulate_triangle_motion(initial_velocity, angle, time_interval, air_resistance=True):
    # Initialize variables
    x = 0.0
    y = 0.0
    time = 0.0

    # Convert angle from degrees to radians
    angle_rad = math.radians(angle)

    # Calculate initial velocities
    vx = initial_velocity * math.cos(angle_rad)
    vy = initial_velocity * math.sin(angle_rad)

    # Simulate the motion until the y-coordinate becomes negative (reached the ground)
    while y >= 0:
        # Calculate the acceleration due to air resistance
        if air_resistance:
            air_resistance_acceleration = -0.5 * vy**2  # Simplified model for air resistance
        else:
            air_resistance_acceleration = 0.0  # No air resistance

        # Calculate the new velocities using the kinematic equations
        vx += air_resistance_acceleration * math.cos(angle_rad) * time_interval
        vy += (-9.8 + air_resistance_acceleration * math.sin(angle_rad)) * time_interval

        # Calculate the new position using the kinematic equations
        x += vx * time_interval
        y += vy * time_interval

        # Increment the time
        time += time_interval

    return x, y, time


# Example usage
angle = 45  # Angle in degrees
side_lengths = 5
opposite_side_length = 3
side_ratio = 2
height = calculate_triangle_height(angle, side_lengths, opposite_side_length, side_ratio)
print(f""The height of the triangle is: {height}"")

initial_velocity = 10  # m/s
time_interval = 0.01  # seconds
x, y, total_time = simulate_triangle_motion(initial_velocity, angle, time_interval, air_resistance=True)
print(f""The triangle reached the ground at coordinates (x={x:.2f}m, y={y:.2f}m) in {total_time:.2f}s."")","هاوردەکردن math

پێناسەکردن calculate_triangle_height(angle, side_lengths, opposite_side_length, side_ratio):
     #Convert angle from degrees to radians
    angle_rad = math.radians(angle)

     #Calculate the height using the Law of Sines
    height = opposite_side_length * math.sin(angle_rad) / side_ratio

     #Calculate the length of the adjacent side using the Law of Cosines
    adjacent_side_length = math.sqrt(side_lengths**2 + opposite_side_length**2 - 2 * side_lengths * opposite_side_length * math.cos(angle_rad))

     #Calculate the hypotenuse of the triangle
    hypotenuse = side_lengths / math.cos(angle_rad)

     #Calculate the remaining side using Pythagorean theorem
    remaining_side_length = math.sqrt(hypotenuse**2 - adjacent_side_length**2)

     #Calculate the final height of the triangle
    height += remaining_side_length

    گەڕانەوە height


پێناسەکردن simulate_triangle_motion(initial_velocity, angle, time_interval, air_resistance=ڕاست):
     #Initialize variables
    x = 0.0
    y = 0.0
    time = 0.0

     #Convert angle from degrees to radians
    angle_rad = math.radians(angle)

     #Calculate initial velocities
    vx = initial_velocity * math.cos(angle_rad)
    vy = initial_velocity * math.sin(angle_rad)

     #Simulate the motion until the y-coordinate becomes negative (reached the ground)
    لەکاتێکدا y >= 0:
         #Calculate the acceleration due to air resistance
        ئەگەر air_resistance:
            air_resistance_acceleration = -0.5 * vy**2 #Simplified model for air resistance
        ئی_تر:
            air_resistance_acceleration = 0.0 #No air resistance

         #Calculate the new velocities using the kinematic equations
        vx += air_resistance_acceleration * math.cos(angle_rad) * time_interval
        vy += (-9.8 + air_resistance_acceleration * math.sin(angle_rad)) * time_interval

         #Calculate the new position using the kinematic equations
        x += vx * time_interval
        y += vy * time_interval

         #Increment the time
        time += time_interval

    گەڕانەوە x, y, time


 #Example usage
angle = 45 #Angle in degrees
side_lengths = 5
opposite_side_length = 3
side_ratio = 2
height = calculate_triangle_height(angle, side_lengths, opposite_side_length, side_ratio)
چاپکردن(f""The height of the triangle is: {height}"")

initial_velocity = 10 #m/s
time_interval = 0.01 #seconds
x, y, total_time = simulate_triangle_motion(initial_velocity, angle, time_interval, air_resistance=ڕاست)
چاپکردن(f""The triangle reached the ground at coordinates (x={x:.2f}m, y={y:.2f}m) in {total_time:.2f}s."")","هاوردەکردن Zimanê_kanîn

پێناسەکردن Dirêjbûna_sêgoşe_hesab_bikin(qozî, dirêjahiya_alî, Dirêjahiya_berevajî, Rêjeya_aliyê):
      # Angle ji dereceyan veguherînin radians
    Angle_Rad = Zimanê_kanîn.radis(qozî)

      # Bilindahiya bi karanîna qanûna gunehan hesab bike
    bilindî = Dirêjahiya_berevajî * Zimanê_kanîn.gûneh(Angle_Rad) / Rêjeya_aliyê

      # Dirêjahiya aliyek cîran bi karanîna zagona kozikan hesab bike
    Dirêjahiya_alîgirê = Zimanê_kanîn.Sqrt(dirêjahiya_alî**2 + Dirêjahiya_berevajî**2 - 2 * dirêjahiya_alî * Dirêjahiya_berevajî * Zimanê_kanîn.Cos(Angle_Rad))

      # Hîpotenuse ya sêgoşeyê hesab bikin
    Hyprotenuse = dirêjahiya_alî / Zimanê_kanîn.Cos(Angle_Rad)

      # Li ser navê teorema pythagorean bi karanîna aliyekî mayî hesab bikin
    Dirêjbûna_aliyê_mayî = Zimanê_kanîn.Sqrt(Hyprotenuse**2 - Dirêjahiya_alîgirê**2)

      # Bilindahiya paşîn a sêgoşeyê hesab bike
    bilindî += Dirêjbûna_aliyê_mayî

    گەڕانەوە bilindî


پێناسەکردن Tevgera_sêgoşe_simûl_bikin(leza_destpêkê, qozî, interval_dema, Berxwedana_hewayî=ڕاست):
      # Guhertoyên destpêkê bikin
    x = 0.0
    y = 0.0
    dem = 0.0

      # Angle ji dereceyan veguherînin radians
    Angle_Rad = Zimanê_kanîn.radis(qozî)

      # Leza destpêkê hesab bikin
    VX = leza_destpêkê * Zimanê_kanîn.Cos(Angle_Rad)
    Vy = leza_destpêkê * Zimanê_kanîn.gûneh(Angle_Rad)

      # Heya ku koordînasyona Y_ya negatîf be (gihîştiye erdê) simûlkirin
    لەکاتێکدا y >= 0:
          # Ji ber berxwedana hewayê lezgîn hesab bikin
        ئەگەر Berxwedana_hewayî:
            Accelerasyona_berxwedana_hewayê = -0.5 * Vy**2 # Modela hêsan ji bo berxwedana hewayê
        ئی_تر:
            Accelerasyona_berxwedana_hewayê = 0.0 # Baweriya hewayê tune

          # Vebijarkên nû bi karanîna hevsengiyên kinematîk hesab bikin
        VX += Accelerasyona_berxwedana_hewayê * Zimanê_kanîn.Cos(Angle_Rad) * interval_dema
        Vy += (-9.8 + Accelerasyona_berxwedana_hewayê * Zimanê_kanîn.gûneh(Angle_Rad)) * interval_dema

          # Helwesta nû bi karanîna wekheviyên kinematîk hesab bikin
        x += VX * interval_dema
        y += Vy * interval_dema

          # Wext zêde dibe
        dem += interval_dema

    گەڕانەوە x, y, dem


  # Bikaranîna mînakî
qozî = 45 # Angle di derece
dirêjahiya_alî = 5
Dirêjahiya_berevajî = 3
Rêjeya_aliyê = 2
bilindî = Dirêjbûna_sêgoşe_hesab_bikin(qozî, dirêjahiya_alî, Dirêjahiya_berevajî, Rêjeya_aliyê)
چاپکردن(an""The height of the triangle is: {height}"")

leza_destpêkê = 10 # m / s
interval_dema = 0.01 # seconds
x, y, Demjimêra_giştî = Tevgera_sêgoşe_simûl_bikin(leza_destpêkê, qozî, interval_dema, Berxwedana_hewayî=ڕاست)
چاپکردن(an""The triangle reached the ground at coordinates (x={x:.2f}m, y={y:.2f}m) in {total_time:.2f}s."")"
"import math

def calculate_circle_area(radius):
    try:
        radius = float(radius)
        if radius <= 0:
            return ""Error: Radius must be a positive number""
        area = math.pi * radius**2
        return ""{:.2f}"".format(area)
    except ValueError:
        return ""Error: Invalid input. Radius must be a number""","هاوردەکردن math

پێناسەکردن calculate_circle_area(radius):
    هەوڵدان:
        radius = خاڵی_هەڵدەفڕێت(radius)
        ئەگەر radius <= 0:
            گەڕانەوە ""Error: Radius must be a positive number""
        area = math.pi * radius**2
        گەڕانەوە ""{:.2f}"".فۆرمات(area)
    جگە_لە هەڵەی_بەها:
        گەڕانەوە ""Error: Invalid input. Radius must be a number""","هاوردەکردن Zimanê_kanîn

پێناسەکردن Qada_dorpêçê_hesab_bikin(çap):
    هەوڵدان:
        çap = خاڵی_هەڵدەفڕێت(çap)
        ئەگەر çap <= 0:
            گەڕانەوە ""Error: Radius must be a positive number""
        dewer = Zimanê_kanîn.pi * çap**2
        گەڕانەوە ""{:.2f}"".فۆرمات(dewer)
    جگە_لە هەڵەی_بەها:
        گەڕانەوە ""Error: Invalid input. Radius must be a number"""
"def multiply_matrices(A, B):
    a, b, c = A[0][0], A[0][1], A[1][0]
    d, e, f = B[0][0], B[0][1], B[1][0]
    
    return [
        [a*d + b*e, a*e + b*f],
        [c*d + e*d, c*e + e*f]
    ]


def power_matrix(A, n):
    if n == 0:
        return [[1, 0], [0, 1]]  # Identity matrix
    
    result = power_matrix(A, n // 2)
    result = multiply_matrices(result, result)
    
    if n % 2 == 1:
        result = multiply_matrices(result, A)
    
    return result


def fibonacci(n):
    if n == 0:
        return 0
    
    matrix = [[1, 1], [1, 0]]
    result = power_matrix(matrix, n - 1)
    
    return result[0][0]","پێناسەکردن multiply_matrices(A, B):
    a, b, c = A[0][0], A[0][1], A[1][0]
    d, e, f = B[0][0], B[0][1], B[1][0]
    
    گەڕانەوە [
        [a*d + b*e, a*e + b*f],
        [c*d + e*d, c*e + e*f]
    ]


پێناسەکردن power_matrix(A, n):
    ئەگەر n == 0:
        گەڕانەوە [[1, 0], [0, 1]] #Identity matrix
    
    result = power_matrix(A, n // 2)
    result = multiply_matrices(result, result)
    
    ئەگەر n % 2 == 1:
        result = multiply_matrices(result, A)
    
    گەڕانەوە result


پێناسەکردن fibonacci(n):
    ئەگەر n == 0:
        گەڕانەوە 0
    
    matrix = [[1, 1], [1, 0]]
    result = power_matrix(matrix, n - 1)
    
    گەڕانەوە result[0][0]","پێناسەکردن Matrices_pirjimar(YEK, Bicî):
    yek, bicî, c = YEK[0][0], YEK[0][1], YEK[1][0]
    D, E, an = Bicî[0][0], Bicî[0][1], Bicî[1][0]
    
    گەڕانەوە [
        [yek*D + bicî*E, yek*E + bicî*an],
        [c*D + E*D, c*E + E*an]
    ]


پێناسەکردن Power_Matrix(YEK, N):
    ئەگەر N == 0:
        گەڕانەوە [[1, 0], [0, 1]] # Matrix nasname
    
    netîce = Power_Matrix(YEK, N // 2)
    netîce = Matrices_pirjimar(netîce, netîce)
    
    ئەگەر N % 2 == 1:
        netîce = Matrices_pirjimar(netîce, YEK)
    
    گەڕانەوە netîce


پێناسەکردن fibonacci(N):
    ئەگەر N == 0:
        گەڕانەوە 0
    
    matrix = [[1, 1], [1, 0]]
    netîce = Power_Matrix(matrix, N - 1)
    
    گەڕانەوە netîce[0][0]"
"def debug_program(arr):
    n = len(arr)
    return binary_search(arr, 0, n - 1)

def binary_search(arr, start, end):
    if start > end:
        return -1
    
    mid = (start + end) // 2
    
    if arr[mid] == mid:
        return mid
    
    left_result = binary_search(arr, start, min(mid - 1, arr[mid]))
    right_result = binary_search(arr, max(mid + 1, arr[mid]), end)
    
    return max(left_result, right_result)","پێناسەکردن debug_program(arr):
    n = درێژی(arr)
    گەڕانەوە binary_search(arr, 0, n - 1)

پێناسەکردن binary_search(arr, start, end):
    ئەگەر start > end:
        گەڕانەوە -1
    
    mid = (start + end) // 2
    
    ئەگەر arr[mid] == mid:
        گەڕانەوە mid
    
    left_result = binary_search(arr, start, کەمترین(mid - 1, arr[mid]))
    right_result = binary_search(arr, زۆرترین(mid + 1, arr[mid]), end)
    
    گەڕانەوە زۆرترین(left_result, right_result)","پێناسەکردن Bernameya_Debug(tar):
    N = درێژی(tar)
    گەڕانەوە binary_lêgerîn(tar, 0, N - 1)

پێناسەکردن binary_lêgerîn(tar, destpêkirin, dawî):
    ئەگەر destpêkirin > dawî:
        گەڕانەوە -1
    
    dî = (destpêkirin + dawî) // 2
    
    ئەگەر tar[dî] == dî:
        گەڕانەوە dî
    
    Encama_çepê = binary_lêgerîn(tar, destpêkirin, کەمترین(dî - 1, tar[dî]))
    encama_rast = binary_lêgerîn(tar, زۆرترین(dî + 1, tar[dî]), dawî)
    
    گەڕانەوە زۆرترین(Encama_çepê, encama_rast)"
"import math

def power(x, y):
    # Check for invalid inputs
    if not isinstance(x, (int, float)) or not isinstance(y, int):
        return ""Error: Invalid input. Please enter numeric values for x and y.""

    # Check if x is between 1 and 10
    if not 1 <= x <= 10:
        return ""Error: x should be between 1 and 10.""

    # Check if y is between 0 and 5
    if not 0 <= y <= 5:
        return ""Error: y should be between 0 and 5.""

    # Custom algorithm for calculating power
    result = x ** y

    # Check if result exceeds threshold for scientific notation
    if result > 1e6:
        return ""{:.2e}"".format(result)
    else:
        return result

# Example usage
x = 2.5
y = 3
result = power(x, y)
print(result)","هاوردەکردن math

پێناسەکردن power(x, y):
     #Check for invalid inputs
    ئەگەر نەخێر نموونەیە(x, (ژمارەیەکی_تەواو, خاڵی_هەڵدەفڕێت)) یان نەخێر نموونەیە(y, ژمارەیەکی_تەواو):
        گەڕانەوە ""Error: Invalid input. Please enter numeric values for x and y.""

     #Check if x is between 1 and 10
    ئەگەر نەخێر 1 <= x <= 10:
        گەڕانەوە ""Error: x should be between 1 and 10.""

     #Check if y is between 0 and 5
    ئەگەر نەخێر 0 <= y <= 5:
        گەڕانەوە ""Error: y should be between 0 and 5.""

     #Custom algorithm for calculating power
    result = x ** y

     #Check if result exceeds threshold for scientific notation
    ئەگەر result > 1e6:
        گەڕانەوە ""{:.2e}"".فۆرمات(result)
    ئی_تر:
        گەڕانەوە result

 #Example usage
x = 2.5
y = 3
result = power(x, y)
چاپکردن(result)","هاوردەکردن Zimanê_kanîn

پێناسەکردن erk(x, y):
      # Ji bo inputên nederbasdar binihêrin
    ئەگەر نەخێر نموونەیە(x, (ژمارەیەکی_تەواو, خاڵی_هەڵدەفڕێت)) یان نەخێر نموونەیە(y, ژمارەیەکی_تەواو):
        گەڕانەوە ""Error: Invalid input. Please enter numeric values for x and y.""

      # Kontrol bikin ka x di navbera 1 û 10 de ye
    ئەگەر نەخێر 1 <= x <= 10:
        گەڕانەوە ""Error: x should be between 1 and 10.""

      # Kontrol bikin ka y di navbera 0 û 5 de ye
    ئەگەر نەخێر 0 <= y <= 5:
        گەڕانەوە ""Error: y should be between 0 and 5.""

      # Algorîtmaya xwerû ji bo hesabkirina hêzê
    netîce = x ** y

      # Kontrol bikin ka encam ji benda ji bo danezana zanistî derbas dibe
    ئەگەر netîce > 1e6:
        گەڕانەوە ""{:.2e}"".فۆرمات(netîce)
    ئی_تر:
        گەڕانەوە netîce

  # Bikaranîna mînakî
x = 2.5
y = 3
netîce = erk(x, y)
چاپکردن(netîce)"
"def bubble_sort_descending(arr):
    n = len(arr)
    for i in range(n - 1):
        for j in range(n - i - 1):
            if arr[j] < arr[j + 1]:
                arr[j], arr[j + 1] = arr[j + 1], arr[j]
    return arr

arr = [3, 2, 1, 5, 4]
sorted_arr = bubble_sort_descending(arr)
print(sorted_arr)","پێناسەکردن bubble_sort_descending(arr):
    n = درێژی(arr)
    بۆ i لەناو ڕێژە(n - 1):
        بۆ j لەناو ڕێژە(n - i - 1):
            ئەگەر arr[j] < arr[j + 1]:
                arr[j], arr[j + 1] = arr[j + 1], arr[j]
    گەڕانەوە arr

arr = [3, 2, 1, 5, 4]
sorted_arr = bubble_sort_descending(arr)
چاپکردن(sorted_arr)","پێناسەکردن Bubble_Sort_Descending(tar):
    N = درێژی(tar)
    بۆ ez لەناو ڕێژە(N - 1):
        بۆ J لەناو ڕێژە(N - ez - 1):
            ئەگەر tar[J] < tar[J + 1]:
                tar[J], tar[J + 1] = tar[J + 1], tar[J]
    گەڕانەوە tar

tar = [3, 2, 1, 5, 4]
arr_teng_kirin = Bubble_Sort_Descending(tar)
چاپکردن(arr_teng_kirin)"
"def sum_prime_numbers(arr):
    def is_prime(n):
        if n <= 1:
            return False
        for i in range(2, int(n**0.5) + 1):
            if n % i == 0:
                return False
        return True

    prime_sum = 0
    for num in arr:
        if is_prime(num):
            prime_sum += num
    return prime_sum","پێناسەکردن sum_prime_numbers(arr):
    پێناسەکردن is_prime(n):
        ئەگەر n <= 1:
            گەڕانەوە هەڵە
        بۆ i لەناو ڕێژە(2, ژمارەیەکی_تەواو(n**0.5) + 1):
            ئەگەر n % i == 0:
                گەڕانەوە هەڵە
        گەڕانەوە ڕاست

    prime_sum = 0
    بۆ num لەناو arr:
        ئەگەر is_prime(num):
            prime_sum += num
    گەڕانەوە prime_sum","پێناسەکردن Hejmarên_Serokwezîr(tar):
    پێناسەکردن Serokwezîr_e(N):
        ئەگەر N <= 1:
            گەڕانەوە هەڵە
        بۆ ez لەناو ڕێژە(2, ژمارەیەکی_تەواو(N**0.5) + 1):
            ئەگەر N % ez == 0:
                گەڕانەوە هەڵە
        گەڕانەوە ڕاست

    Serokwezîr = 0
    بۆ n_ê لەناو tar:
        ئەگەر Serokwezîr_e(n_ê):
            Serokwezîr += n_ê
    گەڕانەوە Serokwezîr"
"def calculate_factorial(n):
    if n == 0:
        return 1
    else:
        return n * calculate_factorial(n - 1)

def calculate_factorials(arr):
    result = []
    for num in arr:
        result.append(calculate_factorial(num))
    return result

arr = [1, 2, 3, 4, 5]
factorials = calculate_factorials(arr)
print(factorials)","پێناسەکردن calculate_factorial(n):
    ئەگەر n == 0:
        گەڕانەوە 1
    ئی_تر:
        گەڕانەوە n * calculate_factorial(n - 1)

پێناسەکردن calculate_factorials(arr):
    result = []
    بۆ num لەناو arr:
        result.زیاد_بکە(calculate_factorial(num))
    گەڕانەوە result

arr = [1, 2, 3, 4, 5]
factorials = calculate_factorials(arr)
چاپکردن(factorials)","پێناسەکردن faktorek_hesab_bikin(N):
    ئەگەر N == 0:
        گەڕانەوە 1
    ئی_تر:
        گەڕانەوە N * faktorek_hesab_bikin(N - 1)

پێناسەکردن faktoran_hesab_bikin(tar):
    netîce = []
    بۆ n_ê لەناو tar:
        netîce.زیاد_بکە(faktorek_hesab_bikin(n_ê))
    گەڕانەوە netîce

tar = [1, 2, 3, 4, 5]
faktor = faktoran_hesab_bikin(tar)
چاپکردن(faktor)"
"def count_vowels(text):
    vowels = ['a', 'e', 'i', 'o', 'u']
    vowel_counts = {vowel: 0 for vowel in vowels}
    
    for char in text:
        if char.lower() in vowels:
            vowel_counts[char.lower()] += 1
    
    return vowel_counts

text = ""Hello World!""
result = count_vowels(text)
print(result)","پێناسەکردن count_vowels(text):
    vowels = ['a', 'e', 'i', 'o', 'u']
    vowel_counts = {vowel: 0 بۆ vowel لەناو vowels}
    
    بۆ char لەناو text:
        ئەگەر char.کەمتر() لەناو vowels:
            vowel_counts[char.کەمتر()] += 1
    
    گەڕانەوە vowel_counts

text = ""Hello World!""
result = count_vowels(text)
چاپکردن(result)","پێناسەکردن Vîdyoyên_hejmartin(nivîstok):
    dîmenên = ['a', 'e', 'i', 'o', 'u']
    hejmartin_vokal = {dengdar: 0 بۆ dengdar لەناو dîmenên}
    
    بۆ ekar لەناو nivîstok:
        ئەگەر ekar.کەمتر() لەناو dîmenên:
            hejmartin_vokal[ekar.کەمتر()] += 1
    
    گەڕانەوە hejmartin_vokal

nivîstok = ""Hello World!""
netîce = Vîdyoyên_hejmartin(nivîstok)
چاپکردن(netîce)"
"import random

def generate_random_number():
    num = 0
    while bin(num).count('1') != 4:
        num = random.randint(0, 15)
    return num

random_number = generate_random_number()
print(random_number)","هاوردەکردن random

پێناسەکردن generate_random_number():
    num = 0
    لەکاتێکدا دوودوویی(num).گێرانەوە('1') != 4:
        num = random.randint(0, 15)
    گەڕانەوە num

random_number = generate_random_number()
چاپکردن(random_number)","هاوردەکردن bêpayîn

پێناسەکردن Jimareya_rastîn_hilberînin():
    n_ê = 0
    لەکاتێکدا دوودوویی(n_ê).گێرانەوە('1') != 4:
        n_ê = bêpayîn.Rarint(0, 15)
    گەڕانەوە n_ê

Hejmara_Rastîn = Jimareya_rastîn_hilberînin()
چاپکردن(Hejmara_Rastîn)"
"def multiply(a, b):
    # Calculate the sign of the result
    sign = -1 if (a < 0) ^ (b < 0) else 1

    # Convert both numbers to positive
    a = abs(a)
    b = abs(b)

    # Initialize the result
    result = 0

    # Multiply the numbers using bitwise operations
    while b:
        # If b is odd, add a to the result
        if b & 1:
            result += a

        # Shift a to the left by 1 bit
        a <<= 1

        # Shift b to the right by 1 bit
        b >>= 1

    return sign * result","پێناسەکردن multiply(a, b):
     #Calculate the sign of the result
    sign = -1 ئەگەر (a < 0) ^ (b < 0) ئی_تر 1

     #Convert both numbers to positive
    a = بەهای_ڕەها(a)
    b = بەهای_ڕەها(b)

     #Initialize the result
    result = 0

     #Multiply the numbers using bitwise operations
    لەکاتێکدا b:
         #If b is odd, add a to the result
        ئەگەر b & 1:
            result += a

         #Shift a to the left by 1 bit
        a <<= 1

         #Shift b to the right by 1 bit
        b >>= 1

    گەڕانەوە sign * result","پێناسەکردن zêdekirin(yek, bicî):
      # Nîşana encamê hesab bike
    nîşan = -1 ئەگەر (yek < 0) ^ (bicî < 0) ئی_تر 1

      # Her du hejmar bi erênî veguherînin
    yek = بەهای_ڕەها(yek)
    bicî = بەهای_ڕەها(bicî)

      # Encama destpêkê bikin
    netîce = 0

      # Hejmarên bi karanîna operasyonên bitwise pirjimar bikin
    لەکاتێکدا bicî:
          # Heke b xerîb e, encama A zêde bikin
        ئەگەر bicî & 1:
            netîce += yek

          # Ji hêla 1 bit 1 ve li milê çepê veguherînin
        yek <<= 1

          # Shift b bi 1 bit
        bicî >>= 1

    گەڕانەوە nîşan * netîce"
"def find_longest_element(lst):
    longest_element = ''
    longest_index = -1
    longest_count = 0
    
    for i, element in enumerate(lst):
        if len(str(element)) > len(longest_element):
            longest_element = str(element)
            longest_index = i
            longest_count = 1
        elif len(str(element)) == len(longest_element):
            longest_count += 1
    
    return longest_element, longest_index, longest_count

# Example usage:
lst = [1, 2.5, 'abc', 'defg', 10.25, -5, 'abcdefg']
longest_element, longest_index, longest_count = find_longest_element(lst)

print(""Longest Element:"", longest_element)
print(""Index of Longest Element:"", longest_index)
print(""Total Occurrences of Longest Element:"", longest_count)","پێناسەکردن find_longest_element(lst):
    longest_element = ''
    longest_index = -1
    longest_count = 0
    
    بۆ i, element لەناو ژمارە_بکەرەوە(lst):
        ئەگەر درێژی(ڕستە(element)) > درێژی(longest_element):
            longest_element = ڕستە(element)
            longest_index = i
            longest_count = 1
        ئەگەرنا_ئەگەر... درێژی(ڕستە(element)) == درێژی(longest_element):
            longest_count += 1
    
    گەڕانەوە longest_element, longest_index, longest_count

 #Example usage:
lst = [1, 2.5, 'abc', 'defg', 10.25, -5, 'abcdefg']
longest_element, longest_index, longest_count = find_longest_element(lst)

چاپکردن(""Longest Element:"", longest_element)
چاپکردن(""Index of Longest Element:"", longest_index)
چاپکردن(""Total Occurrences of Longest Element:"", longest_count)","پێناسەکردن hêmana_dirêjtirîn_bibînin(lst):
    Elementa_herî_dirêj = ''
    Indeksa_herî_dirêj = -1
    hejmartina_dirêjtirîn = 0
    
    بۆ ez, pêve لەناو ژمارە_بکەرەوە(lst):
        ئەگەر درێژی(ڕستە(pêve)) > درێژی(Elementa_herî_dirêj):
            Elementa_herî_dirêj = ڕستە(pêve)
            Indeksa_herî_dirêj = ez
            hejmartina_dirêjtirîn = 1
        ئەگەرنا_ئەگەر... درێژی(ڕستە(pêve)) == درێژی(Elementa_herî_dirêj):
            hejmartina_dirêjtirîn += 1
    
    گەڕانەوە Elementa_herî_dirêj, Indeksa_herî_dirêj, hejmartina_dirêjtirîn

  # Mînak Bikaranîna:
lst = [1, 2.5, 'abc', 'defg', 10.25, -5, 'abcdefg']
Elementa_herî_dirêj, Indeksa_herî_dirêj, hejmartina_dirêjtirîn = hêmana_dirêjtirîn_bibînin(lst)

چاپکردن(""Longest Element:"", Elementa_herî_dirêj)
چاپکردن(""Index of Longest Element:"", Indeksa_herî_dirêj)
چاپکردن(""Total Occurrences of Longest Element:"", hejmartina_dirêjtirîn)"
"import math

def is_prime(num):
    if num <= 1:
        return ""Composite""

    for i in range(2, int(math.sqrt(num)) + 1):
        if num % i == 0:
            return ""Composite""

    return ""Prime""","هاوردەکردن math

پێناسەکردن is_prime(num):
    ئەگەر num <= 1:
        گەڕانەوە ""Composite""

    بۆ i لەناو ڕێژە(2, ژمارەیەکی_تەواو(math.sqrt(num)) + 1):
        ئەگەر num % i == 0:
            گەڕانەوە ""Composite""

    گەڕانەوە ""Prime""","هاوردەکردن Zimanê_kanîn

پێناسەکردن Serokwezîr_e(n_ê):
    ئەگەر n_ê <= 1:
        گەڕانەوە ""Composite""

    بۆ ez لەناو ڕێژە(2, ژمارەیەکی_تەواو(Zimanê_kanîn.Sqrt(n_ê)) + 1):
        ئەگەر n_ê % ez == 0:
            گەڕانەوە ""Composite""

    گەڕانەوە ""Prime"""
"def print_primes_without_five(lower, upper):
    # Step 1: Create a boolean array ""is_prime[0..upper]"" and initialize
    # all entries it as true.
    is_prime = [True] * (upper + 1)
    is_prime[0] = is_prime[1] = False

    # Step 2: Mark all the multiples of prime numbers starting from 2
    # as false.
    p = 2
    while p * p <= upper:
        if is_prime[p]:
            for i in range(p * p, upper + 1, p):
                is_prime[i] = False
        p += 1

    # Step 3: Print all prime numbers in the given range excluding
    # numbers containing the digit 5.
    for num in range(lower, upper + 1):
        if is_prime[num] and '5' not in str(num):
            print(num)","پێناسەکردن print_primes_without_five(کەمتر, پیتی_گەورە):
     #Step 1: Create a boolean array ""is_prime[0..upper]"" and initialize
     #all entries it as true.
    is_prime = [ڕاست] * (پیتی_گەورە + 1)
    is_prime[0] = is_prime[1] = هەڵە

     #Step 2: Mark all the multiples of prime numbers starting from 2
     #as false.
    p = 2
    لەکاتێکدا p * p <= پیتی_گەورە:
        ئەگەر is_prime[p]:
            بۆ i لەناو ڕێژە(p * p, پیتی_گەورە + 1, p):
                is_prime[i] = هەڵە
        p += 1

     #Step 3: Print all prime numbers in the given range excluding
     #numbers containing the digit 5.
    بۆ num لەناو ڕێژە(کەمتر, پیتی_گەورە + 1):
        ئەگەر is_prime[num] و '5' نەخێر لەناو ڕستە(num):
            چاپکردن(num)","پێناسەکردن Primes_bêyî_pênc_çap_bikin(کەمتر, پیتی_گەورە):
      # Gav 1: Arrayek Boolean biafirînin ""is_prime [0..uper]"" û destpêkê
      # Hemî ew wekî rast vedibêje.
    Serokwezîr_e = [ڕاست] * (پیتی_گەورە + 1)
    Serokwezîr_e[0] = Serokwezîr_e[1] = هەڵە

      # Gav 2: Hemî pirjimarên hejmarên pêşîn ên ku ji 2 dest pê dikin nîşan bikin
      # wek derewîn.
    P = 2
    لەکاتێکدا P * P <= پیتی_گەورە:
        ئەگەر Serokwezîr_e[P]:
            بۆ ez لەناو ڕێژە(P * P, پیتی_گەورە + 1, P):
                Serokwezîr_e[ez] = هەڵە
        P += 1

      # Gav 3: Hemî hejmarên pêşîn ên li qada diyarkirî çap bikin
      # hejmarên ku di hejmarê 5 de hene.
    بۆ n_ê لەناو ڕێژە(کەمتر, پیتی_گەورە + 1):
        ئەگەر Serokwezîr_e[n_ê] و '5' نەخێر لەناو ڕستە(n_ê):
            چاپکردن(n_ê)"
"import time

# Function to check if a number is prime
def is_prime(n):
    if n < 2:
        return False
    for i in range(2, int(n**0.5) + 1):
        if n % i == 0:
            return False
    return True

# Caching mechanism for prime numbers
prime_cache = {}

# Modified function to check if a number is prime using caching
def is_prime_cached(n):
    if n in prime_cache:
        return prime_cache[n]
    prime = is_prime(n)
    prime_cache[n] = prime
    return prime

# Timer function
def timer(func):
    def wrapper(*args, **kwargs):
        start = time.time()
        result = func(*args, **kwargs)
        end = time.time()
        print(f""Execution time: {end - start} seconds"")
        return result
    return wrapper

# List comprehension to generate the list of prime numbers
@timer
def generate_prime_palindromic_fibonacci():
    return [num for num in range(10000, 20001) if is_prime_cached(num) and str(num) == str(num)[::-1] and is_fibonacci(num)]

# Function to check if a number is a Fibonacci number
def is_fibonacci(n):
    a, b = 0, 1
    while b < n:
        a, b = b, a + b
    return b == n

# Test the function
primes = generate_prime_palindromic_fibonacci()
print(primes)","هاوردەکردن time

 #Function to check if a number is prime
پێناسەکردن is_prime(n):
    ئەگەر n < 2:
        گەڕانەوە هەڵە
    بۆ i لەناو ڕێژە(2, ژمارەیەکی_تەواو(n**0.5) + 1):
        ئەگەر n % i == 0:
            گەڕانەوە هەڵە
    گەڕانەوە ڕاست

 #Caching mechanism for prime numbers
prime_cache = {}

 #Modified function to check if a number is prime using caching
پێناسەکردن is_prime_cached(n):
    ئەگەر n لەناو prime_cache:
        گەڕانەوە prime_cache[n]
    prime = is_prime(n)
    prime_cache[n] = prime
    گەڕانەوە prime

 #Timer function
پێناسەکردن timer(func):
    پێناسەکردن wrapper(*args, **kwargs):
        start = time.time()
        result = func(*args, **kwargs)
        end = time.time()
        چاپکردن(f""Execution time: {end - start} seconds"")
        گەڕانەوە result
    گەڕانەوە wrapper

 #List comprehension to generate the list of prime numbers
@timer
پێناسەکردن generate_prime_palindromic_fibonacci():
    گەڕانەوە [num بۆ num لەناو ڕێژە(10000, 20001) ئەگەر is_prime_cached(num) و ڕستە(num) == ڕستە(num)[::-1] و is_fibonacci(num)]

 #Function to check if a number is a Fibonacci number
پێناسەکردن is_fibonacci(n):
    a, b = 0, 1
    لەکاتێکدا b < n:
        a, b = b, a + b
    گەڕانەوە b == n

 #Test the function
primes = generate_prime_palindromic_fibonacci()
چاپکردن(primes)","هاوردەکردن dem

  # Fonksiyonên ku hûn hejmarek pêşîn kontrol bikin
پێناسەکردن Serokwezîr_e(N):
    ئەگەر N < 2:
        گەڕانەوە هەڵە
    بۆ ez لەناو ڕێژە(2, ژمارەیەکی_تەواو(N**0.5) + 1):
        ئەگەر N % ez == 0:
            گەڕانەوە هەڵە
    گەڕانەوە ڕاست

  # Mekanîzmaya caching ji bo hejmarên pêşîn
Serokwezîr_Serokwezîr = {}

  # Fonksiyona guherandî da ku hûn hejmarek bi karanîna caching_ê kontrol bikin
پێناسەکردن Serokwezîr_e(N):
    ئەگەر N لەناو Serokwezîr_Serokwezîr:
        گەڕانەوە Serokwezîr_Serokwezîr[N]
    Serokwezîr = Serokwezîr_e(N)
    Serokwezîr_Serokwezîr[N] = Serokwezîr
    گەڕانەوە Serokwezîr

  # Fonksiyona Timer
پێناسەکردن Timer(pêkenok):
    پێناسەکردن wrapper(*args, **kwargs):
        destpêkirin = dem.dem()
        netîce = pêkenok(*args, **kwargs)
        dawî = dem.dem()
        چاپکردن(an""Execution time: {end - start} seconds"")
        گەڕانەوە netîce
    گەڕانەوە wrapper

  # Fêmkirina navnîşê bikin ku navnîşa hejmarên pêşîn hilberînin
@Timer
پێناسەکردن FibonactiCI_ya_pêşîn_a_Serokwezîr_ava_bikin():
    گەڕانەوە [n_ê بۆ n_ê لەناو ڕێژە(10000, 20001) ئەگەر Serokwezîr_e(n_ê) و ڕستە(n_ê) == ڕستە(n_ê)[::-1] و fibonacci_ye(n_ê)]

  # Fonksiyonên ku hûn hejmarek hejmarek fibonacci ye kontrol bikin
پێناسەکردن fibonacci_ye(N):
    yek, bicî = 0, 1
    لەکاتێکدا bicî < N:
        yek, bicî = bicî, yek + bicî
    گەڕانەوە bicî == N

  # Fonksiyonê ceribînin
Primes = FibonactiCI_ya_pêşîn_a_Serokwezîr_ava_bikin()
چاپکردن(Primes)"
"import math

def average_list(lst):
    if not lst:
        return None
    
    if len(lst) == 1:
        return lst[0]
    
    total = 0
    count = 0
    
    for num in lst:
        if not isinstance(num, (int, float)):
            raise ValueError(""List contains non-numeric elements"")
        
        if isinstance(num, complex):
            raise ValueError(""List contains complex numbers"")
        
        if math.isnan(num):
            raise ValueError(""List contains NaN values"")
        
        if math.isinf(num):
            raise ValueError(""List contains infinity or negative infinity values"")
        
        if abs(num) > 1e308:
            raise ValueError(""List contains numbers that are too large"")
        
        total += num
        count += 1
    
    return total / count","هاوردەکردن math

پێناسەکردن average_list(lst):
    ئەگەر نەخێر lst:
        گەڕانەوە None
    
    ئەگەر درێژی(lst) == 1:
        گەڕانەوە lst[0]
    
    total = 0
    گێرانەوە = 0
    
    بۆ num لەناو lst:
        ئەگەر نەخێر نموونەیە(num, (ژمارەیەکی_تەواو, خاڵی_هەڵدەفڕێت)):
            ئیستسنای_بەرز_بکەنەوە هەڵەی_بەها(""List contains non-numeric elements"")
        
        ئەگەر نموونەیە(num, ئاڵۆز):
            ئیستسنای_بەرز_بکەنەوە هەڵەی_بەها(""List contains complex numbers"")
        
        ئەگەر math.isnan(num):
            ئیستسنای_بەرز_بکەنەوە هەڵەی_بەها(""List contains NaN values"")
        
        ئەگەر math.isinf(num):
            ئیستسنای_بەرز_بکەنەوە هەڵەی_بەها(""List contains infinity or negative infinity values"")
        
        ئەگەر بەهای_ڕەها(num) > 1e308:
            ئیستسنای_بەرز_بکەنەوە هەڵەی_بەها(""List contains numbers that are too large"")
        
        total += num
        گێرانەوە += 1
    
    گەڕانەوە total / گێرانەوە","هاوردەکردن Zimanê_kanîn

پێناسەکردن Navnîşa_navîn(lst):
    ئەگەر نەخێر lst:
        گەڕانەوە Netû
    
    ئەگەر درێژی(lst) == 1:
        گەڕانەوە lst[0]
    
    hemî = 0
    گێرانەوە = 0
    
    بۆ n_ê لەناو lst:
        ئەگەر نەخێر نموونەیە(n_ê, (ژمارەیەکی_تەواو, خاڵی_هەڵدەفڕێت)):
            ئیستسنای_بەرز_بکەنەوە هەڵەی_بەها(""List contains non-numeric elements"")
        
        ئەگەر نموونەیە(n_ê, ئاڵۆز):
            ئیستسنای_بەرز_بکەنەوە هەڵەی_بەها(""List contains complex numbers"")
        
        ئەگەر Zimanê_kanîn.isnan(n_ê):
            ئیستسنای_بەرز_بکەنەوە هەڵەی_بەها(""List contains NaN values"")
        
        ئەگەر Zimanê_kanîn.Isinf(n_ê):
            ئیستسنای_بەرز_بکەنەوە هەڵەی_بەها(""List contains infinity or negative infinity values"")
        
        ئەگەر بەهای_ڕەها(n_ê) > 1e308:
            ئیستسنای_بەرز_بکەنەوە هەڵەی_بەها(""List contains numbers that are too large"")
        
        hemî += n_ê
        گێرانەوە += 1
    
    گەڕانەوە hemî / گێرانەوە"
"import sqlite3

def delete_row(connection):
    try:
        # Start a transaction
        connection.execute(""BEGIN TRANSACTION"")

        # Execute the complex query
        cursor = connection.execute(""SELECT ..."")

        # Fetch the row to be deleted
        row = cursor.fetchone()

        if row:
            # Delete the row using its primary key
            connection.execute(""DELETE FROM table_name WHERE id=?"", (row['id'],))

        # Commit the transaction
        connection.execute(""COMMIT"")

        # Close the cursor
        cursor.close()

    except sqlite3.Error as error:
        # Rollback the transaction in case of any exception
        connection.execute(""ROLLBACK"")

        # Display the error message
        print(f""Error: {error}"")

    finally:
        # Close the database connection
        connection.close()

# Create a connection to the SQLite database
connection = sqlite3.connect(""database.db"")

# Call the function to delete the row
delete_row(connection)","هاوردەکردن sqlite3

پێناسەکردن delete_row(connection):
    هەوڵدان:
         #Start a transaction
        connection.execute(""BEGIN TRANSACTION"")

         #Execute the complex query
        cursor = connection.execute(""SELECT ..."")

         #Fetch the row to be deleted
        row = cursor.fetchone()

        ئەگەر row:
             #Delete the row using its primary key
            connection.execute(""DELETE FROM table_name WHERE id=?"", (row['id'],))

         #Commit the transaction
        connection.execute(""COMMIT"")

         #Close the cursor
        cursor.داخستن()

    جگە_لە sqlite3.Error وەک error:
         #Rollback the transaction in case of any exception
        connection.execute(""ROLLBACK"")

         #Display the error message
        چاپکردن(f""Error: {error}"")

    لەکۆتاییدا:
         #Close the database connection
        connection.داخستن()

 #Create a connection to the SQLite database
connection = sqlite3.connect(""database.db"")

 #Call the function to delete the row
delete_row(connection)","هاوردەکردن sqlite3

پێناسەکردن Rêzan_jêbirin(têkêlî):
    هەوڵدان:
          # Danûstendinek dest pê bikin
        têkêlî.dardekirin(""BEGIN TRANSACTION"")

          # Pirsgirêka tevlihev bicîh bikin
        êşkar = têkêlî.dardekirin(""SELECT ..."")

          # Rêzika ku jê were jêbirin fet bikin
        bêrkirin = êşkar.Fetchone()

        ئەگەر bêrkirin:
              # Row bi karanîna mifteya xwe ya bingehîn jêbirin
            têkêlî.dardekirin(""DELETE FROM table_name WHERE id=?"", (bêrkirin['id'],))

          # Danûstendinê pêk bînin
        têkêlî.dardekirin(""COMMIT"")

          # Kursor bigire
        êşkar.داخستن()

    جگە_لە sqlite3.Şaşî وەک şaşî:
          # Di doza her îstîsnayekê de danûstendinê bişopînin
        têkêlî.dardekirin(""ROLLBACK"")

          # Peyama çewtiyê nîşan bide
        چاپکردن(an""Error: {error}"")

    لەکۆتاییدا:
          # Girêdana databasê bigire
        têkêlî.داخستن()

  # Têkiliyek bi databasa Sqlite re çêbikin
têkêlî = sqlite3.bihevgirêdan(""database.db"")

  # Fonksiyonê bang bikin ku rêzê jêbirin
Rêzan_jêbirin(têkêlî)"
"import re

def extract_emails(string):
    # Use regular expression pattern to find all email addresses in the string
    pattern = r'\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}\b'
    matches = re.findall(pattern, string)
    
    # Remove any duplicate email addresses
    unique_emails = list(set(matches))
    
    return unique_emails","هاوردەکردن re

پێناسەکردن extract_emails(string):
     #Use regular expression pattern to find all email addresses in the string
    pattern = r'\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}\b'
    matches = re.findall(pattern, string)
    
     #Remove any duplicate email addresses
    unique_emails = لیست(دانان(matches))
    
    گەڕانەوە unique_emails","هاوردەکردن maf

پێناسەکردن e_nameyan_derxînin(ben):
      # Modela îfadeyê ya birêkûpêk bikar bînin da ku hemî navnîşên e_nameyê di rêzê de bibînin
    mînak = r'\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}\b'
    pêşbazî_dike = maf.Seall(mînak, ben)
    
      # Navnîşanên e_nameyên dubare hilweşînin
    Emails_Unique = لیست(دانان(pêşbazî_dike))
    
    گەڕانەوە Emails_Unique"
"def clean_and_sort(lst):
   result = []
   for element in lst:
      if type(element) == int:
         result.append(element + 5)
   # implement your own sorting algorithm here
   n = len(result)
   for i in range(n):
      for j in range(0, n-i-1):
         if result[j] < result[j+1]:
            result[j], result[j+1] = result[j+1], result[j]
   return result

print(clean_and_sort([1, 2, ""hello""]))","پێناسەکردن clean_and_sort(lst):
   result = []
   بۆ element لەناو lst:
      ئەگەر جۆر(element) == ژمارەیەکی_تەواو:
         result.زیاد_بکە(element + 5)
    #implement your own sorting algorithm here
   n = درێژی(result)
   بۆ i لەناو ڕێژە(n):
      بۆ j لەناو ڕێژە(0, n-i-1):
         ئەگەر result[j] < result[j+1]:
            result[j], result[j+1] = result[j+1], result[j]
   گەڕانەوە result

چاپکردن(clean_and_sort([1, 2, ""hello""]))","پێناسەکردن paqij_û_cûrbecûr(lst):
   netîce = []
   بۆ pêve لەناو lst:
      ئەگەر جۆر(pêve) == ژمارەیەکی_تەواو:
         netîce.زیاد_بکە(pêve + 5)
     # Li vir algorîtmaya xwerû ya xwe bicîh bînin
   N = درێژی(netîce)
   بۆ ez لەناو ڕێژە(N):
      بۆ J لەناو ڕێژە(0, N-ez-1):
         ئەگەر netîce[J] < netîce[J+1]:
            netîce[J], netîce[J+1] = netîce[J+1], netîce[J]
   گەڕانەوە netîce

چاپکردن(paqij_û_cûrbecûr([1, 2, ""hello""]))"
"def is_valid_palindrome(s):
    # Convert the string to lowercase
    s = s.lower()
    
    # Initialize the two pointers
    left = 0
    right = len(s) - 1
    
    while left < right:
        # Check if the left character is not alphabetic
        if not s[left].isalpha():
            left += 1
            continue
        
        # Check if the right character is not alphabetic
        if not s[right].isalpha():
            right -= 1
            continue
        
        # Check if the characters at the two positions are equal
        if s[left] != s[right]:
            return False
        
        # Move the pointers towards the middle
        left += 1
        right -= 1
    
    return True","پێناسەکردن is_valid_palindrome(s):
     #Convert the string to lowercase
    s = s.کەمتر()
    
     #Initialize the two pointers
    left = 0
    right = درێژی(s) - 1
    
    لەکاتێکدا left < right:
         #Check if the left character is not alphabetic
        ئەگەر نەخێر s[left].بە_ئەلفوبێیە():
            left += 1
            بەردەوام_بوون
        
         #Check if the right character is not alphabetic
        ئەگەر نەخێر s[right].بە_ئەلفوبێیە():
            right -= 1
            بەردەوام_بوون
        
         #Check if the characters at the two positions are equal
        ئەگەر s[left] != s[right]:
            گەڕانەوە هەڵە
        
         #Move the pointers towards the middle
        left += 1
        right -= 1
    
    گەڕانەوە ڕاست","پێناسەکردن palindrome_derbasdar_e(S):
      # String bi tîpên piçûk veguherînin
    S = S.کەمتر()
    
      # Du nîşangiran destpêkê bikin
    çep = 0
    rast = درێژی(S) - 1
    
    لەکاتێکدا çep < rast:
          # Kontrol bikin ka karaktera çepê ne alfabet e
        ئەگەر نەخێر S[çep].بە_ئەلفوبێیە():
            çep += 1
            بەردەوام_بوون
        
          # Kontrol bikin ka karektera rast ne alfabet e
        ئەگەر نەخێر S[rast].بە_ئەلفوبێیە():
            rast -= 1
            بەردەوام_بوون
        
          # Kontrol bikin ka tîpên li her du helwestan wekhev in
        ئەگەر S[çep] != S[rast]:
            گەڕانەوە هەڵە
        
          # Nîşanên li ser navîn hilkişînin
        çep += 1
        rast -= 1
    
    گەڕانەوە ڕاست"
"def is_palindrome(num):
    # Convert the number to string
    num_str = str(num)
    
    # Check if the number is positive
    if num <= 0:
        return False
    
    # Check if the number has at least 5 digits
    if len(num_str) < 5:
        return False
    
    # Check if the number consists of unique digits
    if len(set(num_str)) != len(num_str):
        return False
    
    # Check if the number is divisible by 7
    if num % 7 != 0:
        return False
    
    # Check if the number is a palindrome
    if num_str == num_str[::-1]:
        return True
    
    # Check for palindromic substrings within the number
    for i in range(len(num_str)):
        for j in range(i+2, len(num_str)+1):
            sub_num = num_str[i:j]
            if sub_num == sub_num[::-1]:
                return True
    
    return False

# Testing the script
# Decimal number
num_decimal = 12321
print(f""Is {num_decimal} a palindrome? {is_palindrome(num_decimal)}"")

# Hexadecimal number
num_hexadecimal = 0x12321
print(f""Is {num_hexadecimal} a palindrome? {is_palindrome(num_hexadecimal)}"")

# Other test cases
print(f""Is 12345 a palindrome? {is_palindrome(12345)}"")
print(f""Is 1234567 a palindrome? {is_palindrome(1234567)}"")
print(f""Is 12321 a palindrome? {is_palindrome(12321)}"")","پێناسەکردن is_palindrome(num):
     #Convert the number to string
    num_str = ڕستە(num)
    
     #Check if the number is positive
    ئەگەر num <= 0:
        گەڕانەوە هەڵە
    
     #Check if the number has at least 5 digits
    ئەگەر درێژی(num_str) < 5:
        گەڕانەوە هەڵە
    
     #Check if the number consists of unique digits
    ئەگەر درێژی(دانان(num_str)) != درێژی(num_str):
        گەڕانەوە هەڵە
    
     #Check if the number is divisible by 7
    ئەگەر num % 7 != 0:
        گەڕانەوە هەڵە
    
     #Check if the number is a palindrome
    ئەگەر num_str == num_str[::-1]:
        گەڕانەوە ڕاست
    
     #Check for palindromic substrings within the number
    بۆ i لەناو ڕێژە(درێژی(num_str)):
        بۆ j لەناو ڕێژە(i+2, درێژی(num_str)+1):
            sub_num = num_str[i:j]
            ئەگەر sub_num == sub_num[::-1]:
                گەڕانەوە ڕاست
    
    گەڕانەوە هەڵە

 #Testing the script
 #Decimal number
num_decimal = 12321
چاپکردن(f""Is {num_decimal} a palindrome? {is_palindrome(num_decimal)}"")

 #Hexadecimal number
num_hexadecimal = 0x12321
چاپکردن(f""Is {num_hexadecimal} a palindrome? {is_palindrome(num_hexadecimal)}"")

 #Other test cases
چاپکردن(f""Is 12345 a palindrome? {is_palindrome(12345)}"")
چاپکردن(f""Is 1234567 a palindrome? {is_palindrome(1234567)}"")
چاپکردن(f""Is 12321 a palindrome? {is_palindrome(12321)}"")","پێناسەکردن palindrome_ye(n_ê):
      # Hejmara li string veguherînin
    num_str = ڕستە(n_ê)
    
      # Kontrol bikin ka hejmar erênî ye
    ئەگەر n_ê <= 0:
        گەڕانەوە هەڵە
    
      # Kontrol bikin ka hejmar bi kêmî ve 5 hejmar heye
    ئەگەر درێژی(num_str) < 5:
        گەڕانەوە هەڵە
    
      # Kontrol bikin ka hejmar ji hejmarên bêhempa pêk tê
    ئەگەر درێژی(دانان(num_str)) != درێژی(num_str):
        گەڕانەوە هەڵە
    
      # Kontrol bikin ka hejmar ji hêla 7 ve hatî dabeş kirin
    ئەگەر n_ê % 7 != 0:
        گەڕانەوە هەڵە
    
      # Kontrol bikin ku hejmar palindrom e
    ئەگەر num_str == num_str[::-1]:
        گەڕانەوە ڕاست
    
      # Di nav hejmarê de ji bo substroms palindromic kontrol bikin
    بۆ ez لەناو ڕێژە(درێژی(num_str)):
        بۆ J لەناو ڕێژە(ez+2, درێژی(num_str)+1):
            sub_num = num_str[ez:J]
            ئەگەر sub_num == sub_num[::-1]:
                گەڕانەوە ڕاست
    
    گەڕانەوە هەڵە

  # Testkirina skrîptê
  # Hejmara Decimal
Num_Decimal = 12321
چاپکردن(an""Is {num_decimal} a palindrome? {is_palindrome(num_decimal)}"")

  # Hejmara Hexadecimal
Num_Hexadecimal = 0x12321
چاپکردن(an""Is {num_hexadecimal} a palindrome? {is_palindrome(num_hexadecimal)}"")

  # Dozên ceribandinên din
چاپکردن(an""Is 12345 a palindrome? {is_palindrome(12345)}"")
چاپکردن(an""Is 1234567 a palindrome? {is_palindrome(1234567)}"")
چاپکردن(an""Is 12321 a palindrome? {is_palindrome(12321)}"")"
"import re

def remove_vowels(string):
    return re.sub(r'[aeiouAEIOU]', '', string)

def sort_characters(string):
    frequency = {}
    for char in string:
        frequency[char] = frequency.get(char, 0) + 1
    sorted_chars = sorted(frequency.keys(), key=lambda x: (-frequency[x], x))
    return sorted_chars

def remove_vowels_and_sort(string):
    string_without_vowels = remove_vowels(string)
    sorted_string = sort_characters(string_without_vowels)
    return ''.join(sorted_string)","هاوردەکردن re

پێناسەکردن remove_vowels(string):
    گەڕانەوە re.sub(r'[aeiouAEIOU]', '', string)

پێناسەکردن sort_characters(string):
    frequency = {}
    بۆ char لەناو string:
        frequency[char] = frequency.وەرگرتن(char, 0) + 1
    sorted_chars = ڕیزکراوە(frequency.کلیلەکان(), key=لامبدا x: (-frequency[x], x))
    گەڕانەوە sorted_chars

پێناسەکردن remove_vowels_and_sort(string):
    string_without_vowels = remove_vowels(string)
    sorted_string = sort_characters(string_without_vowels)
    گەڕانەوە ''.پەیوەندیکردن(sorted_string)","هاوردەکردن maf

پێناسەکردن dengbêjan_derxînin(ben):
    گەڕانەوە maf.jêr(r'[aeiouAEIOU]', '', ben)

پێناسەکردن Karakterên_cûrbecûr(ben):
    pircarînî = {}
    بۆ ekar لەناو ben:
        pircarînî[ekar] = pircarînî.وەرگرتن(ekar, 0) + 1
    Chars_cûrbecûr = ڕیزکراوە(pircarînî.کلیلەکان(), qûfle=لامبدا x: (-pircarînî[x], x))
    گەڕانەوە Chars_cûrbecûr

پێناسەکردن vokalan_hilînin_û_cûr_bikin(ben):
    string_bê_vokal = dengbêjan_derxînin(ben)
    Rêza_Rêzkirî = Karakterên_cûrbecûr(string_bê_vokal)
    گەڕانەوە ''.پەیوەندیکردن(Rêza_Rêzkirî)"

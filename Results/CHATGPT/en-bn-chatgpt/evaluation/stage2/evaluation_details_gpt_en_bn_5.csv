chunk_size,index,original_code,translated_code,back_translated_code,bleu_score,syntax_valid,structure_score,semantic_score,token_match,overall_score
5,1,"def reverse_matrix(matrix):
    new_matrix = []
    for i in range(len(matrix)):
        new_matrix.append([])
        for j in range(len(matrix[i])):
            new_matrix[i].insert(0, matrix[i][j])
    return new_matrix


# Test case 1
matrix1 = [[1, 2, 3],
           [4, 5, 6],
           [7, 8, 9]]
# Expected output: [[9, 8, 7], [6, 5, 4], [3, 2, 1]]
print(reverse_matrix(matrix1))

# Test case 2
matrix2 = [[1, 2, 3, 4],
           [5, 6, 7, 8]]
# Expected output: [[8, 7, 6, 5], [4, 3, 2, 1]]
print(reverse_matrix(matrix2))

# Test case 3
matrix3 = [[1, 2],
           [3, 4],
           [5, 6]]
# Expected output: [[6, 5], [4, 3], [2, 1]]
print(reverse_matrix(matrix3))","def বিপরীত_ম্যাট্রিক্স(ম্যাট্রিক্স):
    নতুন_ম্যাট্রিক্স = []
    for i in range(len(ম্যাট্রিক্স)):
        নতুন_ম্যাট্রিক্স.append([])
        for j in range(len(ম্যাট্রিক্স[i])):
            নতুন_ম্যাট্রিক্স[i].insert(0, ম্যাট্রিক্স[i][j])
    return নতুন_ম্যাট্রিক্স


 #পরীক্ষা_ক্ষেত্র 1
ম্যাট্রিক্স1 = [[1, 2, 3],
           [4, 5, 6],
           [7, 8, 9]]
 #প্রত্যাশিত_ফলাফল: [[9, 8, 7], [6, 5, 4], [3, 2, 1]]
print(বিপরীত_ম্যাট্রিক্স(ম্যাট্রিক্স1))

 #পরীক্ষা_ক্ষেত্র 2
ম্যাট্রিক্স2 = [[1, 2, 3, 4],
           [5, 6, 7, 8]]
 #প্রত্যাশিত_ফলাফল: [[8, 7, 6, 5], [4, 3, 2, 1]]
print(বিপরীত_ম্যাট্রিক্স(ম্যাট্রিক্স2))

 #পরীক্ষা_ক্ষেত্র 3
ম্যাট্রিক্স3 = [[1, 2],
           [3, 4],
           [5, 6]]
 #প্রত্যাশিত_ফলাফল: [[6, 5], [4, 3], [2, 1]]
print(বিপরীত_ম্যাট্রিক্স(ম্যাট্রিক্স3))","def reverse_matrix(matrix):
    new_matrix = []
    for i in range(len(matrix)):
        new_matrix.append([])
        for j in range(len(matrix[i])):
            new_matrix[i].insert(0, matrix[i][j])
    return new_matrix


# test_case_1
matrix1 = [[1, 2, 3],
           [4, 5, 6],
           [7, 8, 9]]
# expected_result: [[9, 8, 7], [6, 5, 4], [3, 2, 1]]
print(reverse_matrix(matrix1))

# test_case_2
matrix2 = [[1, 2, 3, 4],
           [5, 6, 7, 8]]
# expected_result: [[8, 7, 6, 5], [4, 3, 2, 1]]
print(reverse_matrix(matrix2))

# test_case_3
matrix3 = [[1, 2],
           [3, 4],
           [5, 6]]
# expected_result: [[6, 5], [4, 3], [2, 1]]
print(reverse_matrix(matrix3))",1.0,True,1.0,0.9845489859580994,1.0,0.9969097971916199
5,2,"def fibonacci(n):
    if n == 0:
        return 0
    elif n == 1:
        return 1
    else:
        return fibonacci(n-1) + fibonacci(n-2)

# Example usage
n = 10
fibonacci_number = fibonacci(n)
print(f""The Fibonacci number at index {n} is {fibonacci_number}."")","def ফিবোনাচ্চি(isdigit):
    if isdigit == 0:
        return 0
    elif isdigit == 1:
        return 1
    else:
        return ফিবোনাচ্চি(isdigit-1) + ফিবোনাচ্চি(isdigit-2)

 #উদাহরণ_ব্যবহার
isdigit = 10
ফিবোনাচ্চি_সংখ্যা = ফিবোনাচ্চি(isdigit)
print(f""ইনডেক্স {সংখ্যা} এ ফিবোনাচ্চি সংখ্যা হল {ফিবোনাচ্চি_সংখ্যা}."")","def fibonacci(digit):
    if digit == 0:
        return 0
    elif digit == 1:
        return 1
    else:
        return fibonacci(digit-1) + fibonacci(digit-2)

# Example_usage
digit = 10
fibonacci_number = fibonacci(digit)
print(f""Fibonacci number at index {digit} is {fibonacci_number}."")",0.5877017849220932,True,1.0,0.9375235438346863,1.0,0.9050450657513558
5,3,"def count_unique_consonants(string):
    consonants = set()
    lowercase_string = string.lower()
    for char in lowercase_string:
        if char.isalpha() and char not in 'aeiou':
            consonants.add(char)
    return len(consonants)","def অনন্য_ব্যঞ্জনবর্ণ_গণনা(str):
    ব্যঞ্জনবর্ণ = set()
    ছোটহাতের_স্ট্রিং = str.lower()
    for chr in ছোটহাতের_স্ট্রিং:
        if chr.isalpha() and chr not in 'aeiou':
            ব্যঞ্জনবর্ণ.add(chr)
    return len(ব্যঞ্জনবর্ণ)","def unique_consonant_count(string):
    consonants = set()
    lowercase_string = string.lower()
    for chr in lowercase_string:
        if chr.isalpha() and chr not in 'aeiou':
            consonants.add(chr)
    return len(consonants)",0.7240280999334666,True,0.5,0.9803363084793091,1.0,0.8408728816825551
5,4,"def filter_and_replace(string):
    vowels = ['a', 'e', 'i', 'o', 'u']
    filtered_words = []
    
    words = string.split()
    
    for word in words:
        if any(char.isdigit() or not char.isalpha() for char in word):
            continue
        
        if len(word) > 3 and any(char in vowels for char in word):
            filtered_word = """"
            for char in word:
                if char in vowels:
                    vowel_index = vowels.index(char)
                    next_vowel = vowels[(vowel_index + 1) % len(vowels)]
                    filtered_word += next_vowel
                else:
                    filtered_word += char
            filtered_words.append(filtered_word)
    
    return "" "".join(filtered_words)


# Example usage:
input_string = ""Hello world! This is a test string. Filter me out if I contain numbers or special characters.""
output_string = filter_and_replace(input_string)
print(output_string)","def ছাঁকনি_এবং_প্রতিস্থাপন(str):
    স্বরবর্ণ = ['a', 'e', 'i', 'o', 'u']
    ছাঁকিত_শব্দ = []
    
    শব্দসমূহ = str.split()
    
    for শব্দ in শব্দসমূহ:
        if any(chr.isdigit() or not chr.isalpha() for chr in শব্দ):
            continue
        
        if len(শব্দ) > 3 and any(chr in স্বরবর্ণ for chr in শব্দ):
            ছাঁকিত_শব্দ_একক = """"
            for chr in শব্দ:
                if chr in স্বরবর্ণ:
                    স্বরবর্ণ_সূচক = স্বরবর্ণ.index(chr)
                    পরবর্তী_স্বরবর্ণ = স্বরবর্ণ[(স্বরবর্ণ_সূচক + 1) % len(স্বরবর্ণ)]
                    ছাঁকিত_শব্দ_একক += পরবর্তী_স্বরবর্ণ
                else:
                    ছাঁকিত_শব্দ_একক += chr
            ছাঁকিত_শব্দ.append(ছাঁকিত_শব্দ_একক)
    
    return "" "".join(ছাঁকিত_শব্দ)


 #উদাহরণ ব্যবহার:
ইনপুট_স্ট্রিং = ""Hello world! This is a test string. Filter me out if I contain numbers or special characters.""
আউটপুট_স্ট্রিং = ছাঁকনি_এবং_প্রতিস্থাপন(ইনপুট_স্ট্রিং)
print(আউটপুট_স্ট্রিং)","def filter_and_replace(str):
    vowels = ['a', 'e', 'i', 'o', 'u']
    filtered_words = []
    
    words = str.split()
    
    for word in words:
        if any(chr.isdigit() or not chr.isalpha() for chr in word):
            continue
        
        if len(word) > 3 and any(chr in vowels for chr in word):
            filtered_word_unit = """"
            for chr in word:
                if chr in vowels:
                    vowel_index = vowels.index(chr)
                    next_vowel = vowels[(vowel_index + 1) % len(vowels)]
                    filtered_word_unit += next_vowel
                else:
                    filtered_word_unit += chr
            filtered_words.append(filtered_word_unit)
    
    return "" "".join(filtered_words)


# Example usage:
input_string = ""Hello world! This is a test string. Filter me out if I contain numbers or special characters.""
output_string = filter_and_replace(input_string)
print(output_string)",0.7361938218772761,True,1.0,0.9917307496070862,1.0,0.9455849142968724
5,5,"def isOddPrimeGreaterThan100(number):
    if number <= 100 or number % 2 == 0:  # Check if number is less than or equal to 100 or even
        return False
    for i in range(3, int(number**0.5) + 1, 2):  # Check divisibility by odd numbers only
        if number % i == 0:
            return False
    return True

def findSecondSmallestOddPrimeGreaterThan100(array):
    smallest = secondSmallest = float('inf')
    for number in array:
        if isOddPrimeGreaterThan100(number):
            if number < smallest:
                secondSmallest = smallest
                smallest = number
            elif number < secondSmallest:
                secondSmallest = number
    return secondSmallest","def বিজোড়_মৌলিক_১০০_এর_চেয়ে_বড়(isdigit):
    if isdigit <= ১০০ or isdigit % ২ == ০: #যদি সংখ্যা ১০০ এর চেয়ে ছোট বা সমান বা জোড় হয়
        return False
    for i in range(৩, int(isdigit**০.৫) + ১, ২): #শুধুমাত্র বিজোড় সংখ্যা দ্বারা বিভাজ্যতা পরীক্ষা করুন
        if isdigit % i == ০:
            return False
    return True

def দ্বিতীয়_ক্ষুদ্রতম_বিজোড়_মৌলিক_১০০_এর_চেয়ে_বড়(list):
    ক্ষুদ্রতম = দ্বিতীয়_ক্ষুদ্রতম = float('inf')
    for isdigit in list:
        if বিজোড়_মৌলিক_১০০_এর_চেয়ে_বড়(isdigit):
            if isdigit < ক্ষুদ্রতম:
                দ্বিতীয়_ক্ষুদ্রতম = ক্ষুদ্রতম
                ক্ষুদ্রতম = isdigit
            elif isdigit < দ্বিতীয়_ক্ষুদ্রতম:
                দ্বিতীয়_ক্ষুদ্রতম = isdigit
    return দ্বিতীয়_ক্ষুদ্রতম","def odd_prime_greater_than_100(number):
    if number <= 100 or number % 2 == 0:  # If the number is less than or equal to 100 or even
        return False
    for i in range(3, int(number**0.5) + 1, 2):  # Check divisibility only by odd numbers
        if number % i == 0:
            return False
    return True

def second_smallest_odd_prime_greater_than_100(numbers):
    smallest = second_smallest = float('inf')
    for number in numbers:
        if odd_prime_greater_than_100(number):
            if number < smallest:
                second_smallest = smallest
                smallest = number
            elif number < second_smallest:
                second_smallest = number
    return second_smallest",0.7701310598996123,True,0.5,0.7874534130096436,1.0,0.8115168945818512
5,6,"class SeparatorNotFoundError(Exception):
    pass

class MultipleSeparatorsError(Exception):
    pass

try:
    mystring = ""Hello, World!""
    separator = ""#""

    # Incorrect way to split the string on a separator
    split_string = mystring.split(separator, 1)
    if not split_string:
        raise SeparatorNotFoundError(""Separator not found in string"")

    # Additional Requirement:
    # If the separator is found more than once in the string, raise a custom exception called ""MultipleSeparatorsError""

    # Incorrect way to split the string on a separator
    split_string = mystring.split(separator)
    if len(split_string) > 2:
        raise MultipleSeparatorsError(""Multiple separators found in string"")

except SeparatorNotFoundError as e:
    print(""Error:"", e)

except MultipleSeparatorsError as e:
    print(""Error:"", e)

except Exception as e:
    print(""Error:"", e)","class বিভাজক_না_পাওয়া_ত্রুটি(Exception):
    pass

class একাধিক_বিভাজক_ত্রুটি(Exception):
    pass

try:
    আমার_স্ট্রিং = ""হ্যালো, বিশ্ব!""
    বিভাজক = ""#""

     #বিভাজকের উপর স্ট্রিং বিভক্ত করার ভুল উপায়
    বিভক্ত_স্ট্রিং = আমার_স্ট্রিং.split(বিভাজক, 1)
    if not বিভক্ত_স্ট্রিং:
        raise বিভাজক_না_পাওয়া_ত্রুটি(""স্ট্রিং এ বিভাজক পাওয়া যায়নি"")

     #অতিরিক্ত প্রয়োজনীয়তা:
     #যদি স্ট্রিং এ বিভাজক একাধিকবার পাওয়া যায়, তাহলে ""একাধিক_বিভাজক_ত্রুটি"" নামে একটি কাস্টম ব্যতিক্রম উত্থাপন করুন

     #বিভাজকের উপর স্ট্রিং বিভক্ত করার ভুল উপায়
    বিভক্ত_স্ট্রিং = আমার_স্ট্রিং.split(বিভাজক)
    if len(বিভক্ত_স্ট্রিং) > 2:
        raise একাধিক_বিভাজক_ত্রুটি(""স্ট্রিং এ একাধিক বিভাজক পাওয়া গেছে"")

except বিভাজক_না_পাওয়া_ত্রুটি as ত্রুটি:
    print(""ত্রুটি:"", ত্রুটি)

except একাধিক_বিভাজক_ত্রুটি as ত্রুটি:
    print(""ত্রুটি:"", ত্রুটি)

except Exception as ত্রুটি:
    print(""ত্রুটি:"", ত্রুটি)","class SeparatorNotFoundError(Exception):
    pass

class MultipleSeparatorError(Exception):
    pass

try:
    my_string = ""Hello, World!""
    separator = ""#""

    # Incorrect way to split the string on the separator
    split_string = my_string.split(separator, 1)
    if not split_string:
        raise SeparatorNotFoundError(""Separator not found in the string"")

    # Additional requirement:
    # If the separator is found multiple times in the string, raise a custom exception named ""MultipleSeparatorError""

    # Incorrect way to split the string on the separator
    split_string = my_string.split(separator)
    if len(split_string) > 2:
        raise MultipleSeparatorError(""Multiple separators found in the string"")

except SeparatorNotFoundError as error:
    print(""Error:"", error)

except MultipleSeparatorError as error:
    print(""Error:"", error)

except Exception as error:
    print(""Error:"", error)",0.6348808590228375,True,0.6666666666666666,0.9926303029060364,1.0,0.858835565719108
5,7,"def create_index_dictionary(list_one, list_two):
    if len(list_one) != len(list_two):
        raise ValueError(""Input lists must be of equal length"")
    
    index_dict = {}
    for i in range(len(list_one)):
        if isinstance(list_one[i], (list, dict, tuple)) and isinstance(list_two[i], (list, dict, tuple)):
            if isinstance(list_one[i], set) or isinstance(list_two[i], set):
                raise ValueError(""Input lists cannot contain sets"")
            
            nested_dict = {}
            if isinstance(list_one[i], dict) and isinstance(list_two[i], dict):
                if len(list_one[i]) != len(list_two[i]):
                    raise ValueError(""Nested dictionaries must have the same number of elements"")
                
                for key in list_one[i].keys():
                    if key not in list_two[i]:
                        raise ValueError(""Keys in nested dictionaries must be the same"")
                    nested_dict[key] = (list_one[i][key], list_two[i][key])
            elif isinstance(list_one[i], list) and isinstance(list_two[i], list):
                if len(list_one[i]) != len(list_two[i]):
                    raise ValueError(""Nested lists must have the same length"")
                
                for j in range(len(list_one[i])):
                    nested_dict[j] = (list_one[i][j], list_two[i][j])
            elif isinstance(list_one[i], tuple) and isinstance(list_two[i], tuple):
                if len(list_one[i]) != len(list_two[i]):
                    raise ValueError(""Tuples must have the same length"")
                
                for j in range(len(list_one[i])):
                    nested_dict[j] = (list_one[i][j], list_two[i][j])
            
            index_dict[i] = nested_dict
        else:
            index_dict[i] = (list_one[i], list_two[i])
    
    return index_dict","def সূচক_অভিধান_তৈরি_করা(তালিকা_এক, তালিকা_দুই):
    if len(তালিকা_এক) != len(তালিকা_দুই):
        raise ValueError(""ইনপুট তালিকাগুলি সমান দৈর্ঘ্যের হতে হবে"")
    
    সূচক_অভিধান = {}
    for i in range(len(তালিকা_এক)):
        if isinstance(তালিকা_এক[i], (list, dict, tuple)) and isinstance(তালিকা_দুই[i], (list, dict, tuple)):
            if isinstance(তালিকা_এক[i], set) or isinstance(তালিকা_দুই[i], set):
                raise ValueError(""ইনপুট তালিকাগুলিতে সেট থাকতে পারবে না"")
            
            নেস্টেড_অভিধান = {}
            if isinstance(তালিকা_এক[i], dict) and isinstance(তালিকা_দুই[i], dict):
                if len(তালিকা_এক[i]) != len(তালিকা_দুই[i]):
                    raise ValueError(""নেস্টেড অভিধানগুলির একই সংখ্যক উপাদান থাকতে হবে"")
                
                for keys in তালিকা_এক[i].keys():
                    if keys not in তালিকা_দুই[i]:
                        raise ValueError(""নেস্টেড অভিধানগুলির চাবিগুলি একই হতে হবে"")
                    নেস্টেড_অভিধান[keys] = (তালিকা_এক[i][keys], তালিকা_দুই[i][keys])
            elif isinstance(তালিকা_এক[i], list) and isinstance(তালিকা_দুই[i], list):
                if len(তালিকা_এক[i]) != len(তালিকা_দুই[i]):
                    raise ValueError(""নেস্টেড তালিকাগুলির একই দৈর্ঘ্য থাকতে হবে"")
                
                for j in range(len(তালিকা_এক[i])):
                    নেস্টেড_অভিধান[j] = (তালিকা_এক[i][j], তালিকা_দুই[i][j])
            elif isinstance(তালিকা_এক[i], tuple) and isinstance(তালিকা_দুই[i], tuple):
                if len(তালিকা_এক[i]) != len(তালিকা_দুই[i]):
                    raise ValueError(""টাপলগুলির একই দৈর্ঘ্য থাকতে হবে"")
                
                for j in range(len(তালিকা_এক[i])):
                    নেস্টেড_অভিধান[j] = (তালিকা_এক[i][j], তালিকা_দুই[i][j])
            
            সূচক_অভিধান[i] = নেস্টেড_অভিধান
        else:
            সূচক_অভিধান[i] = (তালিকা_এক[i], তালিকা_দুই[i])
    
    return সূচক_অভিধান","def create_index_dictionary(list_one, list_two):
    if len(list_one) != len(list_two):
        raise ValueError(""Input lists must be of equal length"")
    
    index_dictionary = {}
    for i in range(len(list_one)):
        if isinstance(list_one[i], (list, dict, tuple)) and isinstance(list_two[i], (list, dict, tuple)):
            if isinstance(list_one[i], set) or isinstance(list_two[i], set):
                raise ValueError(""Input lists cannot contain sets"")
            
            nested_dictionary = {}
            if isinstance(list_one[i], dict) and isinstance(list_two[i], dict):
                if len(list_one[i]) != len(list_two[i]):
                    raise ValueError(""Nested dictionaries must have the same number of elements"")
                
                for keys in list_one[i].keys():
                    if keys not in list_two[i]:
                        raise ValueError(""Keys of nested dictionaries must be the same"")
                    nested_dictionary[keys] = (list_one[i][keys], list_two[i][keys])
            elif isinstance(list_one[i], list) and isinstance(list_two[i], list):
                if len(list_one[i]) != len(list_two[i]):
                    raise ValueError(""Nested lists must have the same length"")
                
                for j in range(len(list_one[i])):
                    nested_dictionary[j] = (list_one[i][j], list_two[i][j])
            elif isinstance(list_one[i], tuple) and isinstance(list_two[i], tuple):
                if len(list_one[i]) != len(list_two[i]):
                    raise ValueError(""Tuples must have the same length"")
                
                for j in range(len(list_one[i])):
                    nested_dictionary[j] = (list_one[i][j], list_two[i][j])
            
            index_dictionary[i] = nested_dictionary
        else:
            index_dictionary[i] = (list_one[i], list_two[i])
    
    return index_dictionary",0.9079294006586811,True,1.0,0.9975680112838745,1.0,0.9810994823885111
5,8,"def find_maximum(a, b, c):
    # Convert the numbers to binary
    a_bin = bin(a)
    b_bin = bin(b)
    c_bin = bin(c)
    
    # Count the number of 1s in the binary representation of each number
    a_count = a_bin.count('1')
    b_count = b_bin.count('1')
    c_count = c_bin.count('1')
    
    # Compare the counts to find the maximum
    if a_count > b_count and a_count > c_count:
        return a
    elif b_count > a_count and b_count > c_count:
        return b
    else:
        return c","def সর্বাধিক_খুঁজুন(ক, খ, গ):
     #সংখ্যাগুলিকে বাইনারিতে রূপান্তর করুন
    ক_বাইনারি = bin(ক)
    খ_বাইনারি = bin(খ)
    গ_বাইনারি = bin(গ)
    
     #প্রতিটি সংখ্যার বাইনারি উপস্থাপনায় 1 এর সংখ্যা গণনা করুন
    ক_গণনা = ক_বাইনারি.count('1')
    খ_গণনা = খ_বাইনারি.count('1')
    গ_গণনা = গ_বাইনারি.count('1')
    
     #সর্বাধিক খুঁজতে গণনাগুলির তুলনা করুন
    if ক_গণনা > খ_গণনা and ক_গণনা > গ_গণনা:
        return ক
    elif খ_গণনা > ক_গণনা and খ_গণনা > গ_গণনা:
        return খ
    else:
        return গ","def find_maximum(a, b, c):
    # Convert numbers to binary
    a_binary = bin(a)
    b_binary = bin(b)
    c_binary = bin(c)
    
    # Count the number of 1s in the binary representation of each number
    a_count = a_binary.count('1')
    b_count = b_binary.count('1')
    c_count = c_binary.count('1')
    
    # Compare the counts to find the maximum
    if a_count > b_count and a_count > c_count:
        return a
    elif b_count > a_count and b_count > c_count:
        return b
    else:
        return c",0.7974362239050947,True,1.0,0.9947044253349304,1.0,0.9584281298480051
5,9,"def quick_sort(arr):
    if len(arr) <= 1:
        return arr, 0
    else:
        pivot = arr[0]
        less = [x for x in arr[1:] if x <= pivot]
        greater = [x for x in arr[1:] if x > pivot]
        sorted_less, comparisons_less = quick_sort(less)
        sorted_greater, comparisons_greater = quick_sort(greater)
        comparisons = len(arr) - 1 + comparisons_less + comparisons_greater
        sorted_arr = sorted_greater + [pivot] + sorted_less
        return sorted_arr, comparisons

# Testing the code
arr = [5, 3, 9, 5, 2, 8, 4]
sorted_arr, comparisons = quick_sort(arr)
print(""Sorted Array:"", sorted_arr)
print(""Number of Comparisons:"", comparisons)","def দ্রুত_সাজান(list):
    if len(list) <= 1:
        return list, 0
    else:
        পিভট = list[0]
        lower = [এক্স for এক্স in list[1:] if এক্স <= পিভট]
        বেশি = [এক্স for এক্স in list[1:] if এক্স > পিভট]
        সাজানো_কম, তুলনা_কম = দ্রুত_সাজান(lower)
        সাজানো_বেশি, তুলনা_বেশি = দ্রুত_সাজান(বেশি)
        তুলনা = len(list) - 1 + তুলনা_কম + তুলনা_বেশি
        সাজানো_তালিকা = সাজানো_বেশি + [পিভট] + সাজানো_কম
        return সাজানো_তালিকা, তুলনা

 #কোড_পরীক্ষা
list = [5, 3, 9, 5, 2, 8, 4]
সাজানো_তালিকা, তুলনা = দ্রুত_সাজান(list)
print(""সাজানো তালিকা:"", সাজানো_তালিকা)
print(""তুলনার সংখ্যা:"", তুলনা)","def quick_sort(lst):
    if len(lst) <= 1:
        return lst, 0
    else:
        pivot = lst[0]
        lower = [x for x in lst[1:] if x <= pivot]
        greater = [x for x in lst[1:] if x > pivot]
        sorted_lower, comparisons_lower = quick_sort(lower)
        sorted_greater, comparisons_greater = quick_sort(greater)
        comparisons = len(lst) - 1 + comparisons_lower + comparisons_greater
        sorted_list = sorted_greater + [pivot] + sorted_lower
        return sorted_list, comparisons

# test_code
lst = [5, 3, 9, 5, 2, 8, 4]
sorted_list, comparisons = quick_sort(lst)
print(""Sorted list:"", sorted_list)
print(""Number of comparisons:"", comparisons)",0.6155675038724076,True,1.0,0.9169537425041199,1.0,0.9065042492753055
5,10,"def calculate_distance(point1, point2):
    distance = ((point2[0] - point1[0])**2 + (point2[1] - point1[1])**2 + (point2[2] - point1[2])**2) ** 0.5
    return distance","def দূরত্ব_গণনা(বিন্দু১, বিন্দু২):
    দূরত্ব = ((বিন্দু২[০] - বিন্দু১[০])**২ + (বিন্দু২[১] - বিন্দু১[১])**২ + (বিন্দু২[২] - বিন্দু১[২])**২) ** ০.৫
    return দূরত্ব","def calculate_distance(point1, point2):
    distance = ((point2[0] - point1[0])**2 + (point2[1] - point1[1])**2 + (point2[2] - point1[2])**2) ** 0.5
    return distance",1.0,True,1.0,1.0,1.0,1.0

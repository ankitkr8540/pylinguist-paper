English_code,gpt_translated_code,gpt_partial_back_translated_code
"def reverse_matrix(matrix):
    new_matrix = []
    for i in range(len(matrix)):
        new_matrix.append([])
        for j in range(len(matrix[i])):
            new_matrix[i].insert(0, matrix[i][j])
    return new_matrix


# Test case 1
matrix1 = [[1, 2, 3],
           [4, 5, 6],
           [7, 8, 9]]
# Expected output: [[9, 8, 7], [6, 5, 4], [3, 2, 1]]
print(reverse_matrix(matrix1))

# Test case 2
matrix2 = [[1, 2, 3, 4],
           [5, 6, 7, 8]]
# Expected output: [[8, 7, 6, 5], [4, 3, 2, 1]]
print(reverse_matrix(matrix2))

# Test case 3
matrix3 = [[1, 2],
           [3, 4],
           [5, 6]]
# Expected output: [[6, 5], [4, 3], [2, 1]]
print(reverse_matrix(matrix3))","সংজ্ঞায়িত_করা বিপরীত_ম্যাট্রিক্স(ম্যাট্রিক্স):
    নতুন_ম্যাট্রিক্স = []
    জন্য i ভিতরে পরিসীমা(দৈর্ঘ্য(ম্যাট্রিক্স)):
        নতুন_ম্যাট্রিক্স.সংযোজন([])
        জন্য j ভিতরে পরিসীমা(দৈর্ঘ্য(ম্যাট্রিক্স[i])):
            নতুন_ম্যাট্রিক্স[i].সন্নিবেশ(0, ম্যাট্রিক্স[i][j])
    ফিরে_আসা নতুন_ম্যাট্রিক্স


#পরীক্ষা_ক্ষেত্র 1
ম্যাট্রিক্স1 = [[1, 2, 3],
           [4, 5, 6],
           [7, 8, 9]]
#প্রত্যাশিত_ফলাফল: [[9, 8, 7], [6, 5, 4], [3, 2, 1]]
ছাপা(বিপরীত_ম্যাট্রিক্স(ম্যাট্রিক্স1))

#পরীক্ষা_ক্ষেত্র 2
ম্যাট্রিক্স2 = [[1, 2, 3, 4],
           [5, 6, 7, 8]]
#প্রত্যাশিত_ফলাফল: [[8, 7, 6, 5], [4, 3, 2, 1]]
ছাপা(বিপরীত_ম্যাট্রিক্স(ম্যাট্রিক্স2))

#পরীক্ষা_ক্ষেত্র 3
ম্যাট্রিক্স3 = [[1, 2],
           [3, 4],
           [5, 6]]
#প্রত্যাশিত_ফলাফল: [[6, 5], [4, 3], [2, 1]]
ছাপা(বিপরীত_ম্যাট্রিক্স(ম্যাট্রিক্স3))","def বিপরীত_ম্যাট্রিক্স(ম্যাট্রিক্স):
    নতুন_ম্যাট্রিক্স = []
    for i in range(len(ম্যাট্রিক্স)):
        নতুন_ম্যাট্রিক্স.append([])
        for j in range(len(ম্যাট্রিক্স[i])):
            নতুন_ম্যাট্রিক্স[i].insert(0, ম্যাট্রিক্স[i][j])
    return নতুন_ম্যাট্রিক্স


 #পরীক্ষা_ক্ষেত্র 1
ম্যাট্রিক্স1 = [[1, 2, 3],
           [4, 5, 6],
           [7, 8, 9]]
 #প্রত্যাশিত_ফলাফল: [[9, 8, 7], [6, 5, 4], [3, 2, 1]]
print(বিপরীত_ম্যাট্রিক্স(ম্যাট্রিক্স1))

 #পরীক্ষা_ক্ষেত্র 2
ম্যাট্রিক্স2 = [[1, 2, 3, 4],
           [5, 6, 7, 8]]
 #প্রত্যাশিত_ফলাফল: [[8, 7, 6, 5], [4, 3, 2, 1]]
print(বিপরীত_ম্যাট্রিক্স(ম্যাট্রিক্স2))

 #পরীক্ষা_ক্ষেত্র 3
ম্যাট্রিক্স3 = [[1, 2],
           [3, 4],
           [5, 6]]
 #প্রত্যাশিত_ফলাফল: [[6, 5], [4, 3], [2, 1]]
print(বিপরীত_ম্যাট্রিক্স(ম্যাট্রিক্স3))"
"def fibonacci(n):
    if n == 0:
        return 0
    elif n == 1:
        return 1
    else:
        return fibonacci(n-1) + fibonacci(n-2)

# Example usage
n = 10
fibonacci_number = fibonacci(n)
print(f""The Fibonacci number at index {n} is {fibonacci_number}."")","সংজ্ঞায়িত_করা ফিবোনাচ্চি(সংখ্যা):
    যদি সংখ্যা == 0:
        ফিরে_আসা 0
    অন্যথায়_যদি সংখ্যা == 1:
        ফিরে_আসা 1
    অন্য:
        ফিরে_আসা ফিবোনাচ্চি(সংখ্যা-1) + ফিবোনাচ্চি(সংখ্যা-2)

#উদাহরণ_ব্যবহার
সংখ্যা = 10
ফিবোনাচ্চি_সংখ্যা = ফিবোনাচ্চি(সংখ্যা)
ছাপা(f""ইনডেক্স {সংখ্যা} এ ফিবোনাচ্চি সংখ্যা হল {ফিবোনাচ্চি_সংখ্যা}."")","def ফিবোনাচ্চি(isdigit):
    if isdigit == 0:
        return 0
    elif isdigit == 1:
        return 1
    else:
        return ফিবোনাচ্চি(isdigit-1) + ফিবোনাচ্চি(isdigit-2)

 #উদাহরণ_ব্যবহার
isdigit = 10
ফিবোনাচ্চি_সংখ্যা = ফিবোনাচ্চি(isdigit)
print(f""ইনডেক্স {সংখ্যা} এ ফিবোনাচ্চি সংখ্যা হল {ফিবোনাচ্চি_সংখ্যা}."")"
"def count_unique_consonants(string):
    consonants = set()
    lowercase_string = string.lower()
    for char in lowercase_string:
        if char.isalpha() and char not in 'aeiou':
            consonants.add(char)
    return len(consonants)","সংজ্ঞায়িত_করা অনন্য_ব্যঞ্জনবর্ণ_গণনা(স্ট্রিং):
    ব্যঞ্জনবর্ণ = সেট()
    ছোটহাতের_স্ট্রিং = স্ট্রিং.কম()
    জন্য অক্ষর ভিতরে ছোটহাতের_স্ট্রিং:
        যদি অক্ষর.বর্ণানুক্রমিক() এবং অক্ষর না ভিতরে 'aeiou':
            ব্যঞ্জনবর্ণ.যোগ_করা(অক্ষর)
    ফিরে_আসা দৈর্ঘ্য(ব্যঞ্জনবর্ণ)","def অনন্য_ব্যঞ্জনবর্ণ_গণনা(str):
    ব্যঞ্জনবর্ণ = set()
    ছোটহাতের_স্ট্রিং = str.lower()
    for chr in ছোটহাতের_স্ট্রিং:
        if chr.isalpha() and chr not in 'aeiou':
            ব্যঞ্জনবর্ণ.add(chr)
    return len(ব্যঞ্জনবর্ণ)"
"def filter_and_replace(string):
    vowels = ['a', 'e', 'i', 'o', 'u']
    filtered_words = []
    
    words = string.split()
    
    for word in words:
        if any(char.isdigit() or not char.isalpha() for char in word):
            continue
        
        if len(word) > 3 and any(char in vowels for char in word):
            filtered_word = """"
            for char in word:
                if char in vowels:
                    vowel_index = vowels.index(char)
                    next_vowel = vowels[(vowel_index + 1) % len(vowels)]
                    filtered_word += next_vowel
                else:
                    filtered_word += char
            filtered_words.append(filtered_word)
    
    return "" "".join(filtered_words)


# Example usage:
input_string = ""Hello world! This is a test string. Filter me out if I contain numbers or special characters.""
output_string = filter_and_replace(input_string)
print(output_string)","সংজ্ঞায়িত_করা ছাঁকনি_এবং_প্রতিস্থাপন(স্ট্রিং):
    স্বরবর্ণ = ['a', 'e', 'i', 'o', 'u']
    ছাঁকিত_শব্দ = []
    
    শব্দসমূহ = স্ট্রিং.বিভক্ত()
    
    জন্য শব্দ ভিতরে শব্দসমূহ:
        যদি যেকোনো(অক্ষর.সংখ্যা() বা না অক্ষর.বর্ণানুক্রমিক() জন্য অক্ষর ভিতরে শব্দ):
            চালিয়ে_যাওয়া
        
        যদি দৈর্ঘ্য(শব্দ) > 3 এবং যেকোনো(অক্ষর ভিতরে স্বরবর্ণ জন্য অক্ষর ভিতরে শব্দ):
            ছাঁকিত_শব্দ_একক = """"
            জন্য অক্ষর ভিতরে শব্দ:
                যদি অক্ষর ভিতরে স্বরবর্ণ:
                    স্বরবর্ণ_সূচক = স্বরবর্ণ.সূচক(অক্ষর)
                    পরবর্তী_স্বরবর্ণ = স্বরবর্ণ[(স্বরবর্ণ_সূচক + 1) % দৈর্ঘ্য(স্বরবর্ণ)]
                    ছাঁকিত_শব্দ_একক += পরবর্তী_স্বরবর্ণ
                অন্য:
                    ছাঁকিত_শব্দ_একক += অক্ষর
            ছাঁকিত_শব্দ.সংযোজন(ছাঁকিত_শব্দ_একক)
    
    ফিরে_আসা "" "".যোগদান(ছাঁকিত_শব্দ)


# উদাহরণ ব্যবহার:
ইনপুট_স্ট্রিং = ""Hello world! This is a test string. Filter me out if I contain numbers or special characters.""
আউটপুট_স্ট্রিং = ছাঁকনি_এবং_প্রতিস্থাপন(ইনপুট_স্ট্রিং)
ছাপা(আউটপুট_স্ট্রিং)","def ছাঁকনি_এবং_প্রতিস্থাপন(str):
    স্বরবর্ণ = ['a', 'e', 'i', 'o', 'u']
    ছাঁকিত_শব্দ = []
    
    শব্দসমূহ = str.split()
    
    for শব্দ in শব্দসমূহ:
        if any(chr.isdigit() or not chr.isalpha() for chr in শব্দ):
            continue
        
        if len(শব্দ) > 3 and any(chr in স্বরবর্ণ for chr in শব্দ):
            ছাঁকিত_শব্দ_একক = """"
            for chr in শব্দ:
                if chr in স্বরবর্ণ:
                    স্বরবর্ণ_সূচক = স্বরবর্ণ.index(chr)
                    পরবর্তী_স্বরবর্ণ = স্বরবর্ণ[(স্বরবর্ণ_সূচক + 1) % len(স্বরবর্ণ)]
                    ছাঁকিত_শব্দ_একক += পরবর্তী_স্বরবর্ণ
                else:
                    ছাঁকিত_শব্দ_একক += chr
            ছাঁকিত_শব্দ.append(ছাঁকিত_শব্দ_একক)
    
    return "" "".join(ছাঁকিত_শব্দ)


 #উদাহরণ ব্যবহার:
ইনপুট_স্ট্রিং = ""Hello world! This is a test string. Filter me out if I contain numbers or special characters.""
আউটপুট_স্ট্রিং = ছাঁকনি_এবং_প্রতিস্থাপন(ইনপুট_স্ট্রিং)
print(আউটপুট_স্ট্রিং)"
"def isOddPrimeGreaterThan100(number):
    if number <= 100 or number % 2 == 0:  # Check if number is less than or equal to 100 or even
        return False
    for i in range(3, int(number**0.5) + 1, 2):  # Check divisibility by odd numbers only
        if number % i == 0:
            return False
    return True

def findSecondSmallestOddPrimeGreaterThan100(array):
    smallest = secondSmallest = float('inf')
    for number in array:
        if isOddPrimeGreaterThan100(number):
            if number < smallest:
                secondSmallest = smallest
                smallest = number
            elif number < secondSmallest:
                secondSmallest = number
    return secondSmallest","সংজ্ঞায়িত_করা বিজোড়_মৌলিক_১০০_এর_চেয়ে_বড়(সংখ্যা):
    যদি সংখ্যা <= ১০০ বা সংখ্যা % ২ == ০: #যদি সংখ্যা ১০০ এর চেয়ে ছোট বা সমান বা জোড় হয়
        ফিরে_আসা মিথ্যা
    জন্য i ভিতরে পরিসীমা(৩, পূর্ণসংখ্যা(সংখ্যা**০.৫) + ১, ২): #শুধুমাত্র বিজোড় সংখ্যা দ্বারা বিভাজ্যতা পরীক্ষা করুন
        যদি সংখ্যা % i == ০:
            ফিরে_আসা মিথ্যা
    ফিরে_আসা সত্য

সংজ্ঞায়িত_করা দ্বিতীয়_ক্ষুদ্রতম_বিজোড়_মৌলিক_১০০_এর_চেয়ে_বড়(তালিকা):
    ক্ষুদ্রতম = দ্বিতীয়_ক্ষুদ্রতম = ফ্লোট('inf')
    জন্য সংখ্যা ভিতরে তালিকা:
        যদি বিজোড়_মৌলিক_১০০_এর_চেয়ে_বড়(সংখ্যা):
            যদি সংখ্যা < ক্ষুদ্রতম:
                দ্বিতীয়_ক্ষুদ্রতম = ক্ষুদ্রতম
                ক্ষুদ্রতম = সংখ্যা
            অন্যথায়_যদি সংখ্যা < দ্বিতীয়_ক্ষুদ্রতম:
                দ্বিতীয়_ক্ষুদ্রতম = সংখ্যা
    ফিরে_আসা দ্বিতীয়_ক্ষুদ্রতম","def বিজোড়_মৌলিক_১০০_এর_চেয়ে_বড়(isdigit):
    if isdigit <= ১০০ or isdigit % ২ == ০: #যদি সংখ্যা ১০০ এর চেয়ে ছোট বা সমান বা জোড় হয়
        return False
    for i in range(৩, int(isdigit**০.৫) + ১, ২): #শুধুমাত্র বিজোড় সংখ্যা দ্বারা বিভাজ্যতা পরীক্ষা করুন
        if isdigit % i == ০:
            return False
    return True

def দ্বিতীয়_ক্ষুদ্রতম_বিজোড়_মৌলিক_১০০_এর_চেয়ে_বড়(list):
    ক্ষুদ্রতম = দ্বিতীয়_ক্ষুদ্রতম = float('inf')
    for isdigit in list:
        if বিজোড়_মৌলিক_১০০_এর_চেয়ে_বড়(isdigit):
            if isdigit < ক্ষুদ্রতম:
                দ্বিতীয়_ক্ষুদ্রতম = ক্ষুদ্রতম
                ক্ষুদ্রতম = isdigit
            elif isdigit < দ্বিতীয়_ক্ষুদ্রতম:
                দ্বিতীয়_ক্ষুদ্রতম = isdigit
    return দ্বিতীয়_ক্ষুদ্রতম"
"class SeparatorNotFoundError(Exception):
    pass

class MultipleSeparatorsError(Exception):
    pass

try:
    mystring = ""Hello, World!""
    separator = ""#""

    # Incorrect way to split the string on a separator
    split_string = mystring.split(separator, 1)
    if not split_string:
        raise SeparatorNotFoundError(""Separator not found in string"")

    # Additional Requirement:
    # If the separator is found more than once in the string, raise a custom exception called ""MultipleSeparatorsError""

    # Incorrect way to split the string on a separator
    split_string = mystring.split(separator)
    if len(split_string) > 2:
        raise MultipleSeparatorsError(""Multiple separators found in string"")

except SeparatorNotFoundError as e:
    print(""Error:"", e)

except MultipleSeparatorsError as e:
    print(""Error:"", e)

except Exception as e:
    print(""Error:"", e)","শ্রেণী বিভাজক_না_পাওয়া_ত্রুটি(ব্যতিক্রম):
    অতিক্রম_করা

শ্রেণী একাধিক_বিভাজক_ত্রুটি(ব্যতিক্রম):
    অতিক্রম_করা

চেষ্টা_করা:
    আমার_স্ট্রিং = ""হ্যালো, বিশ্ব!""
    বিভাজক = ""#""

    # বিভাজকের উপর স্ট্রিং বিভক্ত করার ভুল উপায়
    বিভক্ত_স্ট্রিং = আমার_স্ট্রিং.বিভক্ত(বিভাজক, 1)
    যদি না বিভক্ত_স্ট্রিং:
        ব্যতিক্রম_উত্থাপন_করা বিভাজক_না_পাওয়া_ত্রুটি(""স্ট্রিং এ বিভাজক পাওয়া যায়নি"")

    # অতিরিক্ত প্রয়োজনীয়তা:
    # যদি স্ট্রিং এ বিভাজক একাধিকবার পাওয়া যায়, তাহলে ""একাধিক_বিভাজক_ত্রুটি"" নামে একটি কাস্টম ব্যতিক্রম উত্থাপন করুন

    # বিভাজকের উপর স্ট্রিং বিভক্ত করার ভুল উপায়
    বিভক্ত_স্ট্রিং = আমার_স্ট্রিং.বিভক্ত(বিভাজক)
    যদি দৈর্ঘ্য(বিভক্ত_স্ট্রিং) > 2:
        ব্যতিক্রম_উত্থাপন_করা একাধিক_বিভাজক_ত্রুটি(""স্ট্রিং এ একাধিক বিভাজক পাওয়া গেছে"")

ছাড়া বিভাজক_না_পাওয়া_ত্রুটি হিসাবে ত্রুটি:
    ছাপা(""ত্রুটি:"", ত্রুটি)

ছাড়া একাধিক_বিভাজক_ত্রুটি হিসাবে ত্রুটি:
    ছাপা(""ত্রুটি:"", ত্রুটি)

ছাড়া ব্যতিক্রম হিসাবে ত্রুটি:
    ছাপা(""ত্রুটি:"", ত্রুটি)","class বিভাজক_না_পাওয়া_ত্রুটি(Exception):
    pass

class একাধিক_বিভাজক_ত্রুটি(Exception):
    pass

try:
    আমার_স্ট্রিং = ""হ্যালো, বিশ্ব!""
    বিভাজক = ""#""

     #বিভাজকের উপর স্ট্রিং বিভক্ত করার ভুল উপায়
    বিভক্ত_স্ট্রিং = আমার_স্ট্রিং.split(বিভাজক, 1)
    if not বিভক্ত_স্ট্রিং:
        raise বিভাজক_না_পাওয়া_ত্রুটি(""স্ট্রিং এ বিভাজক পাওয়া যায়নি"")

     #অতিরিক্ত প্রয়োজনীয়তা:
     #যদি স্ট্রিং এ বিভাজক একাধিকবার পাওয়া যায়, তাহলে ""একাধিক_বিভাজক_ত্রুটি"" নামে একটি কাস্টম ব্যতিক্রম উত্থাপন করুন

     #বিভাজকের উপর স্ট্রিং বিভক্ত করার ভুল উপায়
    বিভক্ত_স্ট্রিং = আমার_স্ট্রিং.split(বিভাজক)
    if len(বিভক্ত_স্ট্রিং) > 2:
        raise একাধিক_বিভাজক_ত্রুটি(""স্ট্রিং এ একাধিক বিভাজক পাওয়া গেছে"")

except বিভাজক_না_পাওয়া_ত্রুটি as ত্রুটি:
    print(""ত্রুটি:"", ত্রুটি)

except একাধিক_বিভাজক_ত্রুটি as ত্রুটি:
    print(""ত্রুটি:"", ত্রুটি)

except Exception as ত্রুটি:
    print(""ত্রুটি:"", ত্রুটি)"
"def create_index_dictionary(list_one, list_two):
    if len(list_one) != len(list_two):
        raise ValueError(""Input lists must be of equal length"")
    
    index_dict = {}
    for i in range(len(list_one)):
        if isinstance(list_one[i], (list, dict, tuple)) and isinstance(list_two[i], (list, dict, tuple)):
            if isinstance(list_one[i], set) or isinstance(list_two[i], set):
                raise ValueError(""Input lists cannot contain sets"")
            
            nested_dict = {}
            if isinstance(list_one[i], dict) and isinstance(list_two[i], dict):
                if len(list_one[i]) != len(list_two[i]):
                    raise ValueError(""Nested dictionaries must have the same number of elements"")
                
                for key in list_one[i].keys():
                    if key not in list_two[i]:
                        raise ValueError(""Keys in nested dictionaries must be the same"")
                    nested_dict[key] = (list_one[i][key], list_two[i][key])
            elif isinstance(list_one[i], list) and isinstance(list_two[i], list):
                if len(list_one[i]) != len(list_two[i]):
                    raise ValueError(""Nested lists must have the same length"")
                
                for j in range(len(list_one[i])):
                    nested_dict[j] = (list_one[i][j], list_two[i][j])
            elif isinstance(list_one[i], tuple) and isinstance(list_two[i], tuple):
                if len(list_one[i]) != len(list_two[i]):
                    raise ValueError(""Tuples must have the same length"")
                
                for j in range(len(list_one[i])):
                    nested_dict[j] = (list_one[i][j], list_two[i][j])
            
            index_dict[i] = nested_dict
        else:
            index_dict[i] = (list_one[i], list_two[i])
    
    return index_dict","সংজ্ঞায়িত_করা সূচক_অভিধান_তৈরি_করা(তালিকা_এক, তালিকা_দুই):
    যদি দৈর্ঘ্য(তালিকা_এক) != দৈর্ঘ্য(তালিকা_দুই):
        ব্যতিক্রম_উত্থাপন_করা মান_ত্রুটি(""ইনপুট তালিকাগুলি সমান দৈর্ঘ্যের হতে হবে"")
    
    সূচক_অভিধান = {}
    জন্য i ভিতরে পরিসীমা(দৈর্ঘ্য(তালিকা_এক)):
        যদি উদাহরণ(তালিকা_এক[i], (তালিকা, অভিধান, টাপল)) এবং উদাহরণ(তালিকা_দুই[i], (তালিকা, অভিধান, টাপল)):
            যদি উদাহরণ(তালিকা_এক[i], সেট) বা উদাহরণ(তালিকা_দুই[i], সেট):
                ব্যতিক্রম_উত্থাপন_করা মান_ত্রুটি(""ইনপুট তালিকাগুলিতে সেট থাকতে পারবে না"")
            
            নেস্টেড_অভিধান = {}
            যদি উদাহরণ(তালিকা_এক[i], অভিধান) এবং উদাহরণ(তালিকা_দুই[i], অভিধান):
                যদি দৈর্ঘ্য(তালিকা_এক[i]) != দৈর্ঘ্য(তালিকা_দুই[i]):
                    ব্যতিক্রম_উত্থাপন_করা মান_ত্রুটি(""নেস্টেড অভিধানগুলির একই সংখ্যক উপাদান থাকতে হবে"")
                
                জন্য চাবি ভিতরে তালিকা_এক[i].চাবি():
                    যদি চাবি না ভিতরে তালিকা_দুই[i]:
                        ব্যতিক্রম_উত্থাপন_করা মান_ত্রুটি(""নেস্টেড অভিধানগুলির চাবিগুলি একই হতে হবে"")
                    নেস্টেড_অভিধান[চাবি] = (তালিকা_এক[i][চাবি], তালিকা_দুই[i][চাবি])
            অন্যথায়_যদি উদাহরণ(তালিকা_এক[i], তালিকা) এবং উদাহরণ(তালিকা_দুই[i], তালিকা):
                যদি দৈর্ঘ্য(তালিকা_এক[i]) != দৈর্ঘ্য(তালিকা_দুই[i]):
                    ব্যতিক্রম_উত্থাপন_করা মান_ত্রুটি(""নেস্টেড তালিকাগুলির একই দৈর্ঘ্য থাকতে হবে"")
                
                জন্য j ভিতরে পরিসীমা(দৈর্ঘ্য(তালিকা_এক[i])):
                    নেস্টেড_অভিধান[j] = (তালিকা_এক[i][j], তালিকা_দুই[i][j])
            অন্যথায়_যদি উদাহরণ(তালিকা_এক[i], টাপল) এবং উদাহরণ(তালিকা_দুই[i], টাপল):
                যদি দৈর্ঘ্য(তালিকা_এক[i]) != দৈর্ঘ্য(তালিকা_দুই[i]):
                    ব্যতিক্রম_উত্থাপন_করা মান_ত্রুটি(""টাপলগুলির একই দৈর্ঘ্য থাকতে হবে"")
                
                জন্য j ভিতরে পরিসীমা(দৈর্ঘ্য(তালিকা_এক[i])):
                    নেস্টেড_অভিধান[j] = (তালিকা_এক[i][j], তালিকা_দুই[i][j])
            
            সূচক_অভিধান[i] = নেস্টেড_অভিধান
        অন্য:
            সূচক_অভিধান[i] = (তালিকা_এক[i], তালিকা_দুই[i])
    
    ফিরে_আসা সূচক_অভিধান","def সূচক_অভিধান_তৈরি_করা(তালিকা_এক, তালিকা_দুই):
    if len(তালিকা_এক) != len(তালিকা_দুই):
        raise ValueError(""ইনপুট তালিকাগুলি সমান দৈর্ঘ্যের হতে হবে"")
    
    সূচক_অভিধান = {}
    for i in range(len(তালিকা_এক)):
        if isinstance(তালিকা_এক[i], (list, dict, tuple)) and isinstance(তালিকা_দুই[i], (list, dict, tuple)):
            if isinstance(তালিকা_এক[i], set) or isinstance(তালিকা_দুই[i], set):
                raise ValueError(""ইনপুট তালিকাগুলিতে সেট থাকতে পারবে না"")
            
            নেস্টেড_অভিধান = {}
            if isinstance(তালিকা_এক[i], dict) and isinstance(তালিকা_দুই[i], dict):
                if len(তালিকা_এক[i]) != len(তালিকা_দুই[i]):
                    raise ValueError(""নেস্টেড অভিধানগুলির একই সংখ্যক উপাদান থাকতে হবে"")
                
                for keys in তালিকা_এক[i].keys():
                    if keys not in তালিকা_দুই[i]:
                        raise ValueError(""নেস্টেড অভিধানগুলির চাবিগুলি একই হতে হবে"")
                    নেস্টেড_অভিধান[keys] = (তালিকা_এক[i][keys], তালিকা_দুই[i][keys])
            elif isinstance(তালিকা_এক[i], list) and isinstance(তালিকা_দুই[i], list):
                if len(তালিকা_এক[i]) != len(তালিকা_দুই[i]):
                    raise ValueError(""নেস্টেড তালিকাগুলির একই দৈর্ঘ্য থাকতে হবে"")
                
                for j in range(len(তালিকা_এক[i])):
                    নেস্টেড_অভিধান[j] = (তালিকা_এক[i][j], তালিকা_দুই[i][j])
            elif isinstance(তালিকা_এক[i], tuple) and isinstance(তালিকা_দুই[i], tuple):
                if len(তালিকা_এক[i]) != len(তালিকা_দুই[i]):
                    raise ValueError(""টাপলগুলির একই দৈর্ঘ্য থাকতে হবে"")
                
                for j in range(len(তালিকা_এক[i])):
                    নেস্টেড_অভিধান[j] = (তালিকা_এক[i][j], তালিকা_দুই[i][j])
            
            সূচক_অভিধান[i] = নেস্টেড_অভিধান
        else:
            সূচক_অভিধান[i] = (তালিকা_এক[i], তালিকা_দুই[i])
    
    return সূচক_অভিধান"
"def find_maximum(a, b, c):
    # Convert the numbers to binary
    a_bin = bin(a)
    b_bin = bin(b)
    c_bin = bin(c)
    
    # Count the number of 1s in the binary representation of each number
    a_count = a_bin.count('1')
    b_count = b_bin.count('1')
    c_count = c_bin.count('1')
    
    # Compare the counts to find the maximum
    if a_count > b_count and a_count > c_count:
        return a
    elif b_count > a_count and b_count > c_count:
        return b
    else:
        return c","সংজ্ঞায়িত_করা সর্বাধিক_খুঁজুন(ক, খ, গ):
    #সংখ্যাগুলিকে বাইনারিতে রূপান্তর করুন
    ক_বাইনারি = বাইনারি(ক)
    খ_বাইনারি = বাইনারি(খ)
    গ_বাইনারি = বাইনারি(গ)
    
    #প্রতিটি সংখ্যার বাইনারি উপস্থাপনায় 1 এর সংখ্যা গণনা করুন
    ক_গণনা = ক_বাইনারি.গণনা('1')
    খ_গণনা = খ_বাইনারি.গণনা('1')
    গ_গণনা = গ_বাইনারি.গণনা('1')
    
    #সর্বাধিক খুঁজতে গণনাগুলির তুলনা করুন
    যদি ক_গণনা > খ_গণনা এবং ক_গণনা > গ_গণনা:
        ফিরে_আসা ক
    অন্যথায়_যদি খ_গণনা > ক_গণনা এবং খ_গণনা > গ_গণনা:
        ফিরে_আসা খ
    অন্য:
        ফিরে_আসা গ","def সর্বাধিক_খুঁজুন(ক, খ, গ):
     #সংখ্যাগুলিকে বাইনারিতে রূপান্তর করুন
    ক_বাইনারি = bin(ক)
    খ_বাইনারি = bin(খ)
    গ_বাইনারি = bin(গ)
    
     #প্রতিটি সংখ্যার বাইনারি উপস্থাপনায় 1 এর সংখ্যা গণনা করুন
    ক_গণনা = ক_বাইনারি.count('1')
    খ_গণনা = খ_বাইনারি.count('1')
    গ_গণনা = গ_বাইনারি.count('1')
    
     #সর্বাধিক খুঁজতে গণনাগুলির তুলনা করুন
    if ক_গণনা > খ_গণনা and ক_গণনা > গ_গণনা:
        return ক
    elif খ_গণনা > ক_গণনা and খ_গণনা > গ_গণনা:
        return খ
    else:
        return গ"
"def quick_sort(arr):
    if len(arr) <= 1:
        return arr, 0
    else:
        pivot = arr[0]
        less = [x for x in arr[1:] if x <= pivot]
        greater = [x for x in arr[1:] if x > pivot]
        sorted_less, comparisons_less = quick_sort(less)
        sorted_greater, comparisons_greater = quick_sort(greater)
        comparisons = len(arr) - 1 + comparisons_less + comparisons_greater
        sorted_arr = sorted_greater + [pivot] + sorted_less
        return sorted_arr, comparisons

# Testing the code
arr = [5, 3, 9, 5, 2, 8, 4]
sorted_arr, comparisons = quick_sort(arr)
print(""Sorted Array:"", sorted_arr)
print(""Number of Comparisons:"", comparisons)","সংজ্ঞায়িত_করা দ্রুত_সাজান(তালিকা):
    যদি দৈর্ঘ্য(তালিকা) <= 1:
        ফিরে_আসা তালিকা, 0
    অন্য:
        পিভট = তালিকা[0]
        কম = [এক্স জন্য এক্স ভিতরে তালিকা[1:] যদি এক্স <= পিভট]
        বেশি = [এক্স জন্য এক্স ভিতরে তালিকা[1:] যদি এক্স > পিভট]
        সাজানো_কম, তুলনা_কম = দ্রুত_সাজান(কম)
        সাজানো_বেশি, তুলনা_বেশি = দ্রুত_সাজান(বেশি)
        তুলনা = দৈর্ঘ্য(তালিকা) - 1 + তুলনা_কম + তুলনা_বেশি
        সাজানো_তালিকা = সাজানো_বেশি + [পিভট] + সাজানো_কম
        ফিরে_আসা সাজানো_তালিকা, তুলনা

#কোড_পরীক্ষা
তালিকা = [5, 3, 9, 5, 2, 8, 4]
সাজানো_তালিকা, তুলনা = দ্রুত_সাজান(তালিকা)
ছাপা(""সাজানো তালিকা:"", সাজানো_তালিকা)
ছাপা(""তুলনার সংখ্যা:"", তুলনা)","def দ্রুত_সাজান(list):
    if len(list) <= 1:
        return list, 0
    else:
        পিভট = list[0]
        lower = [এক্স for এক্স in list[1:] if এক্স <= পিভট]
        বেশি = [এক্স for এক্স in list[1:] if এক্স > পিভট]
        সাজানো_কম, তুলনা_কম = দ্রুত_সাজান(lower)
        সাজানো_বেশি, তুলনা_বেশি = দ্রুত_সাজান(বেশি)
        তুলনা = len(list) - 1 + তুলনা_কম + তুলনা_বেশি
        সাজানো_তালিকা = সাজানো_বেশি + [পিভট] + সাজানো_কম
        return সাজানো_তালিকা, তুলনা

 #কোড_পরীক্ষা
list = [5, 3, 9, 5, 2, 8, 4]
সাজানো_তালিকা, তুলনা = দ্রুত_সাজান(list)
print(""সাজানো তালিকা:"", সাজানো_তালিকা)
print(""তুলনার সংখ্যা:"", তুলনা)"
"def calculate_distance(point1, point2):
    distance = ((point2[0] - point1[0])**2 + (point2[1] - point1[1])**2 + (point2[2] - point1[2])**2) ** 0.5
    return distance","সংজ্ঞায়িত_করা দূরত্ব_গণনা(বিন্দু১, বিন্দু২):
    দূরত্ব = ((বিন্দু২[০] - বিন্দু১[০])**২ + (বিন্দু২[১] - বিন্দু১[১])**২ + (বিন্দু২[২] - বিন্দু১[২])**২) ** ০.৫
    ফিরে_আসা দূরত্ব","def দূরত্ব_গণনা(বিন্দু১, বিন্দু২):
    দূরত্ব = ((বিন্দু২[০] - বিন্দু১[০])**২ + (বিন্দু২[১] - বিন্দু১[১])**২ + (বিন্দু২[২] - বিন্দু১[২])**২) ** ০.৫
    return দূরত্ব"
